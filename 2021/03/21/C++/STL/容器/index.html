
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>容器 - JeremyYv&#39;s Blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="TriDiamond Obsidian,"> 
    <meta name="description" content="个人, 条款1. 慎重选择容器类型
标准STL序列容器：vector、string、deque和list
标准STL关联容器：set、map、multiset和multimap
非标准的关联容器：hash,"> 
    <meta name="author" content="JeremyYv"> 
    <link rel="alternative" href="atom.xml" title="JeremyYv&#39;s Blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

    
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">JeremyYv&#39;s Blog</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://JeremyYvv.github.io">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">容器</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url(/img/cover.jpg) ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="/categories/STL"><b>「
                    </b>STL<b> 」</b></a>
                
                三月 21, 2021
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2021/03/21/C++/STL/%E5%AE%B9%E5%99%A8/" title="容器" class="">容器</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>文章字数</i>
                    8.5k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>阅读约需</i>
                    8 mins.
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>阅读次数</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
            <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/C-%E5%BA%93/" rel="tag">C++库</a></li><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <h2 id="条款1-慎重选择容器类型"><a class="markdownIt-Anchor" href="#条款1-慎重选择容器类型"></a> 条款1. 慎重选择容器类型</h2>
<p><strong>标准STL序列容器</strong>：vector、string、deque和list<br />
<strong>标准STL关联容器</strong>：set、map、multiset和multimap<br />
<strong>非标准的关联容器</strong>：hash_set、hash_multiset、hash_map和hash_multimap<br />
<strong>标准的非STL容器</strong>：数组、bitset、valarray、stack、queue和priority_queue</p>
<p>另一种分类：<br />
<strong>连续内存容器</strong>(元素存放在一块或多块内存中，每块内存中存有多个元素)：vector、string和deque<br />
<strong>基于节点的容器</strong>(每块内存存放一个元素)：list和所有标准的关联容器</p>
<hr />
<h2 id="条款2-不要试图编写独立于容器类型的代码"><a class="markdownIt-Anchor" href="#条款2-不要试图编写独立于容器类型的代码"></a> 条款2. 不要试图编写独立于容器类型的代码</h2>
<p>序列容器与关联容器数据结构不同 ，<strong>所提供的操作也不同</strong>。<br />
序列容器支持<code>push_front</code>或<code>push_back</code>，但关联容器不支持。<br />
关联容器提供对数时间复杂度的<code>lower_bound</code>、<code>upper_bound</code>和<code>equal_range</code>成员函数，但序列容器却没有。<br />
写既要和序列容器又要和关联容器一起工作的代码并没有什么意义。<strong>很多成员函数(包括运算符重载)只存在于其中一类容器中</strong>。</p>
<hr />
<h2 id="条款3-确保容器中的对象拷贝正确且高效"><a class="markdownIt-Anchor" href="#条款3-确保容器中的对象拷贝正确且高效"></a> 条款3. 确保容器中的对象拷贝正确且高效</h2>
<p>当你向容器中添加一个对象（比如通过<code>insert</code>或<code>push_back</code>等），进入容器的是你指定的对象的<strong>拷贝</strong>，<br />
如果你从vector、string或deque中插入或删除了什么或使用了任何排序算法，现有的<strong>容器元素会移动（拷贝）</strong>。<br />
因此把一个派生类对象插入基类对象的容器会导致派生部分被删除，而且容器中如果放的对象拷贝过程很昂贵，<strong>元素的移动会成为性能瓶颈</strong>，<br />
所以使拷贝更高效、正确而且对分割问题免疫的简单的方式是<strong>建立指针的容器而不是对象的容器</strong>。但是指针容器也有自己的问题，详见条款7和条款33。</p>
<hr />
<h2 id="条款4-调用empty而不是检查size是否为0"><a class="markdownIt-Anchor" href="#条款4-调用empty而不是检查size是否为0"></a> 条款4. 调用empty()而不是检查size()是否为0</h2>
<p><strong>empty的典型实现是一个返回<code>size()==0</code>结果的内联函数</strong>。<br />
对于所有的标准容器，<strong>empty是一个常数时间的操作</strong>，但对于一些list实现，<strong>size花费线性时间</strong>。<br />
<strong>list中有一个变量用于记录元素个数</strong>。特殊的是，<code>list::splice()</code>用于拼接两个list，为了达到splice的高效率，<strong>在splice时可能不更新size</strong>，而在<strong>调用size时遍历list计算size</strong>，<br />
这就会导致size()花费线性时间而不是常数时间。<br />
但书中没有说empty()为什么一定是常数时间。<br />
所以我看了下我所用的QT中list::empty()的实现方式，发现<strong>list是由循化链表实现的</strong>，<strong>empty()的实现是判断头节点的下个节点是否还是头结点，因此为常数时间</strong>。<br />
所以我的理解是：<strong>由于STL的实现方式不同，<code>empty()</code>的效率比<code>0 == size()</code>更加稳定(如循环链表实现的List)。</strong></p>
<hr />
<h2 id="条款5-区间成员函数优先于与之对应的单元素成员函数"><a class="markdownIt-Anchor" href="#条款5-区间成员函数优先于与之对应的单元素成员函数"></a> 条款5. 区间成员函数优先于与之对应的单元素成员函数</h2>
<p>本文以<code>insert</code>的单元素版本和区间版本说明，区间成员函数优点有三：</p>
<ol>
<li><strong>省去了没有必要的函数调用</strong>，调用1次与调用n次，即使将单元素版本声明为内联，也有可能不会成为内联。</li>
<li>每次<code>insert</code>单元素，<strong>要将插入位置后的所有元素进行移动</strong>，进行拷贝，区间<code>insert</code>则先算好一共要插入的总数，然后将插入位置后的元素<strong>只整体挪动一次</strong></li>
<li>看原因3前需要先看Part2.条款14中，了解序列容器插入元素时内存的重新分配机制。<strong>多次插入单元素可能导致内存多次重新分配</strong>，而<strong>区间插入则一次性分配足够的空间</strong>，然后进行插入。</li>
</ol>
<p><strong>常用区间成员函数整理：</strong><br />
区间构造：</p>
<pre class="highlight"><code class="">container::container(InputIterator begin, InputIterator end); 

begin和end为旧容器中，被拷贝区间的起始
</code></pre>
<p>区间插入：</p>
<pre class="highlight"><code class="">序列容器：void container::insert(iterator position,InputIterator begin, InputIterator end); 
关联容器：void container::insert(lnputIterator begin, InputIterator end);//关联容器使用自己的比较函数决定插入元素放在哪

begin和end为旧容器中，要插到新容器中的区间起始
position为新容器中，要插入位置的迭代器，新元素插入到该迭代器之前
</code></pre>
<p>区间删除：</p>
<pre class="highlight"><code class="">C++11以上: iterator container::erase(iterator begin, iterator end);
C++11以下: 关联容器erase()返回值void

将容器中[begin, end)前闭后开区间内的元素删除
</code></pre>
<p>区间赋值：</p>
<pre class="highlight"><code class="">void container::assign(InputIterator begin, InputIterator end);

begin和end为旧容器中，被拷贝区间的起始
</code></pre>
<hr />
<h2 id="条款6当心c编译器最烦人的分析机制"><a class="markdownIt-Anchor" href="#条款6当心c编译器最烦人的分析机制"></a> 条款6.当心C++编译器最烦人的分析机制</h2>
<p>按照条款5中所说，尝试使用list的区间构造，以一个文件中的全部内容构造一个list对象data</p>
<pre class="highlight"><code class="">ifstream dataFile(&quot;ints.dat&quot;);
list&lt;int&gt; data(istream_iterator&lt;int&gt;(dataFile), istream_iterator&lt;int&gt;());
</code></pre>
<p>上面这段代码乍一看好像没有问题，从文件的begin开始，一直迭代到NULL，即文件末尾，以此区间内的元素构造对象data。<br />
但是编译器会将第二句代码<strong>解析为一个函数声明</strong>。<strong>问题出在构造时使用了一个匿名迭代器</strong>。<br />
目前最好的解决方式，是<strong>在数据声明中避免使用匿名迭代器对象</strong>。</p>
<pre class="highlight"><code class="">ifstream dataFile(&quot;ints.dat&quot;);
istream_iterator&lt;int&gt; dataBegin(dataFile);
istream_iterator&lt;int&gt; dataEnd;
list&lt;int&gt; data(dataBegin, dataEnd);
</code></pre>
<hr />
<h2 id="条款7如果在容器中包含了通过new操作创建的指针切记在容器对象析构前将指针delete掉"><a class="markdownIt-Anchor" href="#条款7如果在容器中包含了通过new操作创建的指针切记在容器对象析构前将指针delete掉"></a> 条款7.如果在容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉</h2>
<p>可以通过遍历容器释放指针，这样做能行，但不是异常安全的。<br />
如果在向容器中放入和释放指针时有异常抛出，同样会有资源泄露。<br />
所以最安全的做法是<strong>用引用计数智能指针（如Boost::shared_ptr）容器代替指针容器。</strong><br />
<strong>ps.不要创建auto_ptr的容器，并指望其中的指针被自动删除，详见下一条款</strong></p>
<hr />
<h2 id="条款8切勿创建包含auto_ptr的容器对象"><a class="markdownIt-Anchor" href="#条款8切勿创建包含auto_ptr的容器对象"></a> 条款8.切勿创建包含auto_ptr的容器对象</h2>
<p><strong>auto_ptr最大的古怪在于它的拷贝构造和赋值操作符，会将被拷贝的指针置为NULL。</strong><br />
STL算法中的<strong>sort()<strong>采用的快速排序算法，会用临时对象拷贝vector中的值作为基准值。<br />
这将导致</strong>vector&lt;auto_ptr&gt;调用sort()时，其中的值被临时对象拷贝，vector中的值被置为NULL，临时对象在作用域结束时释放了该auto_ptr</strong>。<br />
**ps.**C<ins>标准委员会做了很多使vector&lt;auto_ptr&gt;不被编译通过，并最终在C</ins>11中移除了auto_ptr.</p>
<hr />
<h2 id="条款9慎重选择删除元素的方法"><a class="markdownIt-Anchor" href="#条款9慎重选择删除元素的方法"></a> 条款9.慎重选择删除元素的方法</h2>
<h3 id="911-对于连续内存的容器vector-deuqe和string删除元素的最好办法是使用erase-remove"><a class="markdownIt-Anchor" href="#911-对于连续内存的容器vector-deuqe和string删除元素的最好办法是使用erase-remove"></a> 9.1.1. 对于连续内存的容器(vector、deuqe和string)，删除元素的最好办法是使用erase-remove</h3>
<pre class="highlight"><code class="">vec.erase( std::remove(vec.begin(), vec.end(), value), vec.end());
</code></pre>
<p><strong>erase-remove讲解</strong>：先要说一下erase和remove，</p>
<pre class="highlight"><code class="">std::remove (Itertor first, Itertor last, const T&amp; val);
    是&lt;algorithm&gt;中的算法，通过传入的迭代器确定容器遍历区间，将区间中不等于val的元素依次拷贝到区间中的前端。
    完成遍历之后即确定了一段由first起始，没有val值的新区间，
    最后返回该新区间后一个位置的迭代器
</code></pre>
<pre class="highlight"><code class="">iterator erase (iterator first, iterator last);
    将前开后闭区间[first, last)中的元素删除，返回last
</code></pre>
<pre class="highlight"><code class="">erase-remove:
    先通过remove将容器遍历，将不等于value值的元素放在容器前端新区间
    再将新区间后一个位置的迭代器和容器的end()传入erase，将新区间以外的部分删除
</code></pre>
<h3 id="912-对于listerase-remove同样适用但listremove更有效详见条款44"><a class="markdownIt-Anchor" href="#912-对于listerase-remove同样适用但listremove更有效详见条款44"></a> 9.1.2. 对于list，erase-remove同样适用，但list::remove()更有效(详见条款44)</h3>
<pre class="highlight"><code class="">list.remove(value);
从list中移除所有值等于value的元素
</code></pre>
<h3 id="913-对于关联容器set-multiset-map-multimap删除元素正确且高效的方法是调用erase高效的原因详见条款19不要对关联容器使用stdremove详见条款22"><a class="markdownIt-Anchor" href="#913-对于关联容器set-multiset-map-multimap删除元素正确且高效的方法是调用erase高效的原因详见条款19不要对关联容器使用stdremove详见条款22"></a> 9.1.3. 对于关联容器(set、multiset、map、multimap)，删除元素正确且高效的方法是调用erase（高效的原因详见条款19），不要对关联容器使用std::remove（详见条款22）</h3>
<pre class="highlight"><code class="">set.erase(value);
从set中删除所有值为value的元素（multiset中也是删除所有）
</code></pre>
<p><strong>ps.书中提到，序列容器erase会返回下一个位置的迭代器，而关联容器erase返回void，所以序列容器可以通过<code>iter = vec.erase(iter)</code>获得erase后有效的迭代器，而关联容器则要通过<code>set.erase(iter++)</code>后置++的方式获得。</strong><br />
不过我在QtCreator和VisualStudio2005两个编译器都试了下，<strong>关联容器erase的返回值已经是下一个元素的迭代器</strong>了，两种容器可以都通过<code>iter = vec.erase(iter)</code>有效迭代，但对于序列容器不要使用<code>vec.erase(iter++)</code>,因为<strong>序列容器调用erase后，会使被删除元素之后所有的迭代器失效</strong>（虽然QtCreator对此有优化，但在visual studio中的确如此，还是不要这么使用的好）。</p>
<h3 id="92-要删除容器中满足特定判别式的所有对象序列容器使用erase-remove_iflist使用listremove_if关联容器使用遍历erase没有erase_if"><a class="markdownIt-Anchor" href="#92-要删除容器中满足特定判别式的所有对象序列容器使用erase-remove_iflist使用listremove_if关联容器使用遍历erase没有erase_if"></a> 9.2. 要删除容器中满足特定判别式的所有对象，序列容器使用erase-remove_if，list使用list::remove_if，关联容器使用遍历+erase(没有erase_if)</h3>
<pre class="highlight"><code class="">bool badvalue(int); //特定判别式
</code></pre>
<pre class="highlight"><code class="">vec.erase( std::remove_if( vec.begin(),  vec.end(),  badvalue));
    序列容器，遍历vec，删除使badvalue返回true的对象
</code></pre>
<pre class="highlight"><code class="">list.remove_if(badvalue);
    list::remove_if是删除使badvalue返回true的对象的最好办法
</code></pre>
<pre class="highlight"><code class="">for(auto iter = set.begin(); iter != set.end(); /*for第三个参数什么也不做*/)
&#123;
    if(badvalue(*i))  set.erase(iter++);
    else  ++iter;
&#125;
</code></pre>
<hr />
<p><em>如有错误，欢迎指正</em></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
            
            <div class="post-nav">
                <hr>
                
                    <div class="post-nav-item">上一篇:<a href="/2021/03/21/C++/STL/vector%E5%92%8Cstring/" rel="prev" 
                        title="vector和string">vector和string
                      </a></div>
                
                
                    <div class="post-nav-item">下一篇:<a href="/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" rel="next" 
                        title="状态模式">状态模式</a></div>
                                
            </div>   
                        
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='true'
        data-ci='ec894e2b66f752e8b7fb'
        data-cs='3ccc2e92bb350688fe2c2dc2930189b62622bfb1'
        data-r='blog-comments'
        data-o='TriDiamond'
        data-a='TriDiamond'
        data-d=''
    >留言</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="https://res.cloudinary.com/tridiamond/image/upload/v1573019751/TriDiamond_logo_ui_xeublz.jpg" height=300 width=300></img>
                    <p>JeremyYv</p>
                    <span>Think like an artist, develop like an artisan</span>
                    <dl>
                        <dd><a href="https://github.com/TriDiamond" target="_blank"><span
                                    class=" iconfont icon-github"></span></a></dd>
                        <dd><a href="https://twitter.com/TriDiamond6" target="_blank"><span
                                    class=" iconfont icon-twitter"></span></a></dd>
                        <dd><a href="https://stackoverflow.com/users/7602324/tridiamond?tab=profile" target="_blank"><span
                                    class=" iconfont icon-stack-overflow"></span></a></dd>
                    </dl>
                </div>
                <ul>
                    <li><a href="/">30 <p>文章</p></a></li>
                    <li><a href="/categories">3 <p>分类</p></a></li>
                    <li><a href="/tags">8 <p>标签</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>目录</h4>
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE1-%E6%85%8E%E9%87%8D%E9%80%89%E6%8B%A9%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text"> 条款1. 慎重选择容器类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE2-%E4%B8%8D%E8%A6%81%E8%AF%95%E5%9B%BE%E7%BC%96%E5%86%99%E7%8B%AC%E7%AB%8B%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text"> 条款2. 不要试图编写独立于容器类型的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE3-%E7%A1%AE%E4%BF%9D%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E6%AD%A3%E7%A1%AE%E4%B8%94%E9%AB%98%E6%95%88"><span class="toc-number">3.</span> <span class="toc-text"> 条款3. 确保容器中的对象拷贝正确且高效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE4-%E8%B0%83%E7%94%A8empty%E8%80%8C%E4%B8%8D%E6%98%AF%E6%A3%80%E6%9F%A5size%E6%98%AF%E5%90%A6%E4%B8%BA0"><span class="toc-number">4.</span> <span class="toc-text"> 条款4. 调用empty()而不是检查size()是否为0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE5-%E5%8C%BA%E9%97%B4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BC%98%E5%85%88%E4%BA%8E%E4%B8%8E%E4%B9%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8D%95%E5%85%83%E7%B4%A0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text"> 条款5. 区间成员函数优先于与之对应的单元素成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE6%E5%BD%93%E5%BF%83c%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%80%E7%83%A6%E4%BA%BA%E7%9A%84%E5%88%86%E6%9E%90%E6%9C%BA%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text"> 条款6.当心C++编译器最烦人的分析机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE7%E5%A6%82%E6%9E%9C%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8C%85%E5%90%AB%E4%BA%86%E9%80%9A%E8%BF%87new%E6%93%8D%E4%BD%9C%E5%88%9B%E5%BB%BA%E7%9A%84%E6%8C%87%E9%92%88%E5%88%87%E8%AE%B0%E5%9C%A8%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%9E%90%E6%9E%84%E5%89%8D%E5%B0%86%E6%8C%87%E9%92%88delete%E6%8E%89"><span class="toc-number">7.</span> <span class="toc-text"> 条款7.如果在容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE8%E5%88%87%E5%8B%BF%E5%88%9B%E5%BB%BA%E5%8C%85%E5%90%ABauto_ptr%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.</span> <span class="toc-text"> 条款8.切勿创建包含auto_ptr的容器对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE9%E6%85%8E%E9%87%8D%E9%80%89%E6%8B%A9%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text"> 条款9.慎重选择删除元素的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#911-%E5%AF%B9%E4%BA%8E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%B9%E5%99%A8vector-deuqe%E5%92%8Cstring%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A5%BD%E5%8A%9E%E6%B3%95%E6%98%AF%E4%BD%BF%E7%94%A8erase-remove"><span class="toc-number">9.1.</span> <span class="toc-text"> 9.1.1. 对于连续内存的容器(vector、deuqe和string)，删除元素的最好办法是使用erase-remove</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#912-%E5%AF%B9%E4%BA%8Elisterase-remove%E5%90%8C%E6%A0%B7%E9%80%82%E7%94%A8%E4%BD%86listremove%E6%9B%B4%E6%9C%89%E6%95%88%E8%AF%A6%E8%A7%81%E6%9D%A1%E6%AC%BE44"><span class="toc-number">9.2.</span> <span class="toc-text"> 9.1.2. 对于list，erase-remove同样适用，但list::remove()更有效(详见条款44)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#913-%E5%AF%B9%E4%BA%8E%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8set-multiset-map-multimap%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E6%AD%A3%E7%A1%AE%E4%B8%94%E9%AB%98%E6%95%88%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E8%B0%83%E7%94%A8erase%E9%AB%98%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0%E8%AF%A6%E8%A7%81%E6%9D%A1%E6%AC%BE19%E4%B8%8D%E8%A6%81%E5%AF%B9%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8stdremove%E8%AF%A6%E8%A7%81%E6%9D%A1%E6%AC%BE22"><span class="toc-number">9.3.</span> <span class="toc-text"> 9.1.3. 对于关联容器(set、multiset、map、multimap)，删除元素正确且高效的方法是调用erase（高效的原因详见条款19），不要对关联容器使用std::remove（详见条款22）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92-%E8%A6%81%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%BB%A1%E8%B6%B3%E7%89%B9%E5%AE%9A%E5%88%A4%E5%88%AB%E5%BC%8F%E7%9A%84%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8erase-remove_iflist%E4%BD%BF%E7%94%A8listremove_if%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E9%81%8D%E5%8E%86erase%E6%B2%A1%E6%9C%89erase_if"><span class="toc-number">9.4.</span> <span class="toc-text"> 9.2. 要删除容器中满足特定判别式的所有对象，序列容器使用erase-remove_if，list使用list::remove_if，关联容器使用遍历+erase(没有erase_if)</span></a></li></ol></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>

    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2021
        <span class="gradient-text">
            JeremyYv
        </span>.
        Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.5" target="_blank" rel="noopener">v1.4.5</a></small>
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>


 
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">
 
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>
  
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
 
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
 
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>
 
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>
   
<script src="/js/busuanzi.min.js"></script>

<script>
  $(document).ready(function () {
    if ($('span[id^="busuanzi_"]').length) {
      initialBusuanzi();
    }
  });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="//www.googletagmanager.com/gtag/js?id=UA-149874671-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'UA-149874671-1');
</script>
 

<script>
  function initialTyped() {
    var typedTextEl = $('.typed-text');
    if (typedTextEl && typedTextEl.length > 0) {
      var typed = new Typed('.typed-text', {
        strings: ['Think like an artist, develop like an artisan', '艺术家思维去思考问题，工匠创造精神去开发'],
        typeSpeed: 90,
        loop: true,
        loopCount: Infinity,
        backSpeed: 20,
      });
    }
  }

  if ($('.article-header') && $('.article-header').length) {
    $(document).ready(function () {
      initialTyped();
    });
  }
</script>




 <!-- 例：百度统计 --> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?your_code"; var s = document.getElementsByTagName("script")[0];  s.parentNode.insertBefore(hm, s); })(); </script> 

</html>
