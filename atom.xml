<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JeremyYv&#39;s Blog</title>
  
  
  <link href="https://jeremyyvv.github.io/atom.xml" rel="self"/>
  
  <link href="https://jeremyyvv.github.io/"/>
  <updated>2021-03-21T14:47:54.651Z</updated>
  <id>https://jeremyyvv.github.io/</id>
  
  <author>
    <name>JeremyYv</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>默认构造函数</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/C++/ObjectModel/default-constructor/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/C++/ObjectModel/default-constructor/</id>
    <published>2021-03-21T12:11:00.000Z</published>
    <updated>2021-03-21T14:47:54.651Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1804.pdf">C++05标准文档</a> 中 Section 12.1.5 关于默认构造函数的说明</p><blockquote><p>A default constructor for a class X is a constructor of class X that can be called without an argument. If there is no user- declared constructor for class X, a default constructor is implicitly declared<br />类X的默认构造函数是一个无参构造函数，在类X中没有用户声明的构造函数时，被隐式声明。</p></blockquote><hr /><h2 id="q1用户未定义构造函数时默认构造函数一定会被生成吗"><a class="markdownIt-Anchor" href="#q1用户未定义构造函数时默认构造函数一定会被生成吗"></a> Q1：用户未定义构造函数时，默认构造函数一定会被生成吗？</h2><h2 id="a1不一定"><a class="markdownIt-Anchor" href="#a1不一定"></a> A1：不一定。</h2><p>在上一段Section 12.1.5 的说明后，还有一段额外的说明</p><blockquote><p>A default constructor is trivial if it is implicitly-declared and if:<br />its class has no virtual functions and no virtual base classes, and<br />all the direct base classes of its class have trivial default constructors, and<br />for all the non-static data members of its class that are of class type (or array thereof), each such class has a trivial default constructor.<br />一个隐式声明的默认构造函数将是无价值（trivial）的，如果<br />类里没有虚函数和虚基类，并且<br />类的直接基类都有无价值的默认构造函数，并且<br />类中所有非静态成员变量都有无价值的默认构造函数<br />可见，即使是默认构造函数，也被分为了有价值（non-trivial）和无价值（trivial）两种。<br />而对于无价值的默认构造函数，实际上并不会被生成。</p></blockquote><h3 id="求证"><a class="markdownIt-Anchor" href="#求证"></a> 求证</h3><p>通过反汇编，对比用户定义无参构造和默认构造，查看在类的实例过程中是否被调用。</p><h3 id="1-类内定义无参构造函数"><a class="markdownIt-Anchor" href="#1-类内定义无参构造函数"></a> 1. 类内定义无参构造函数</h3><pre class="highlight"><code class="cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;</span><span class="hljs-keyword">public</span>:    Demo()&#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Demo a;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>编译完成后查看反汇编（截取text段中相关的一段）:</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-number">400546</span>:   <span class="hljs-number">55</span>                      push   %rbp  <span class="hljs-number">400547</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                mov    %rsp,%rbp  <span class="hljs-number">40054</span>a:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>             sub    $<span class="hljs-number">0x10</span>,%rsp  <span class="hljs-number">40054</span>e:   <span class="hljs-number">64</span> <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span>    mov    %fs:<span class="hljs-number">0x28</span>,%rax  <span class="hljs-number">400555</span>:   <span class="hljs-number">00</span> <span class="hljs-number">00</span>   <span class="hljs-number">400557</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> f8             mov    %rax,<span class="hljs-number">-0x8</span>(%rbp)  <span class="hljs-number">40055b</span>:   <span class="hljs-number">31</span> c0                   <span class="hljs-keyword">xor</span>    %eax,%eax    Demo a;   <span class="hljs-number">40055</span>d:   <span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">45</span> f7             lea    <span class="hljs-number">-0x9</span>(%rbp),%rax  <span class="hljs-number">400561</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> c7                mov    %rax,%rdi  <span class="hljs-number">400564</span>:   e8 <span class="hljs-number">1b</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          callq  <span class="hljs-number">400584</span> &lt;_ZN4DemoC1Ev&gt;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-number">400569</span>:   b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    $<span class="hljs-number">0x0</span>,%eax&#125;  <span class="hljs-number">40056</span>e:   <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">55</span> f8             mov    <span class="hljs-number">-0x8</span>(%rbp),%rdx  <span class="hljs-number">400572</span>:   <span class="hljs-number">64</span> <span class="hljs-number">48</span> <span class="hljs-number">33</span> <span class="hljs-number">14</span> <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">xor</span>    %fs:<span class="hljs-number">0x28</span>,%rdx  <span class="hljs-number">400579</span>:   <span class="hljs-number">00</span> <span class="hljs-number">00</span>   <span class="hljs-number">40057b</span>:   <span class="hljs-number">74</span> <span class="hljs-number">05</span>                   je     <span class="hljs-number">400582</span> &lt;main+<span class="hljs-number">0x3c</span>&gt;  <span class="hljs-number">40057</span>d:   e8 <span class="hljs-number">9</span>e fe ff ff          callq  <span class="hljs-number">400420</span> &lt;__stack_chk_fail@plt&gt;  <span class="hljs-number">400582</span>:   c9                      leaveq  <span class="hljs-number">400583</span>:   c3                      retq<span class="hljs-number">0000000000400584</span> &lt;_ZN4DemoC1Ev&gt;:<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;</span><span class="hljs-keyword">public</span>:    Demo()&#123;&#125;  <span class="hljs-number">400584</span>:   <span class="hljs-number">55</span>                      push   %rbp  <span class="hljs-number">400585</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                mov    %rsp,%rbp  <span class="hljs-number">400588</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8             mov    %rdi,<span class="hljs-number">-0x8</span>(%rbp)  <span class="hljs-number">40058</span>c:   <span class="hljs-number">90</span>                      nop  <span class="hljs-number">40058</span>d:   <span class="hljs-number">5</span>d                      pop    %rbp  <span class="hljs-number">40058</span>e:   c3                      retq  <span class="hljs-number">40058f</span>:   <span class="hljs-number">90</span>                      nop</code></pre><p>Line13 main函数中，<strong>Demo a;</strong> 调用了Demo类的无参构造函数 <strong>_ZN4DemoC1Ev</strong>.</p><h3 id="2-类内不定义无参构造函数查看是否会调用默认构造函数"><a class="markdownIt-Anchor" href="#2-类内不定义无参构造函数查看是否会调用默认构造函数"></a> 2. 类内不定义无参构造函数，查看是否会调用默认构造函数</h3><pre class="highlight"><code class="cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> &#123;</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Derived a;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;编译完成后查看反汇编（截取text段中相关的一段）:<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-number">4004</span>d6:   <span class="hljs-number">55</span>                      push   %rbp  <span class="hljs-number">4004</span>d7:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                mov    %rsp,%rbp    Demo a;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-number">4004</span>da:   b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    $<span class="hljs-number">0x0</span>,%eax&#125;  <span class="hljs-number">4004</span>df:   <span class="hljs-number">5</span>d                      pop    %rbp  <span class="hljs-number">4004e0</span>:   c3                      retq     <span class="hljs-number">4004e1</span>:   <span class="hljs-number">66</span> <span class="hljs-number">2</span>e <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">84</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>    nopw   %cs:<span class="hljs-number">0x0</span>(%rax,%rax,<span class="hljs-number">1</span>)  <span class="hljs-number">4004e8</span>:   <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>   <span class="hljs-number">4004</span>eb:   <span class="hljs-number">0f</span> <span class="hljs-number">1f</span> <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          nopl   <span class="hljs-number">0x0</span>(%rax,%rax,<span class="hljs-number">1</span>)<span class="hljs-number">00000000004004f</span>0 &lt;__libc_csu_init&gt;:</code></pre><p>可见，并没有生成或调用默认构造函数，因为类Demo中没有虚函数/虚基类，且所有成员变量和直接基类都没有non-trivial默认构造或用户声明构造函数。</p><h3 id="3-作为对比只在空类中写个虚函数看看是否会按照标准中说的那样生成一个有价值的默认构造函数"><a class="markdownIt-Anchor" href="#3-作为对比只在空类中写个虚函数看看是否会按照标准中说的那样生成一个有价值的默认构造函数"></a> 3. 作为对比，只在空类中写个虚函数，看看是否会按照标准中说的那样，生成一个有价值的默认构造函数</h3><pre class="highlight"><code class="cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Demo a;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;编译完成后查看反汇编：<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-number">400676</span>:   <span class="hljs-number">55</span>                      push   %rbp  <span class="hljs-number">400677</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                mov    %rsp,%rbp  <span class="hljs-number">40067</span>a:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>             sub    $<span class="hljs-number">0x10</span>,%rsp  <span class="hljs-number">40067</span>e:   <span class="hljs-number">64</span> <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">04</span> <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span>    mov    %fs:<span class="hljs-number">0x28</span>,%rax  <span class="hljs-number">400685</span>:   <span class="hljs-number">00</span> <span class="hljs-number">00</span>   <span class="hljs-number">400687</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">45</span> f8             mov    %rax,<span class="hljs-number">-0x8</span>(%rbp)  <span class="hljs-number">40068b</span>:   <span class="hljs-number">31</span> c0                   <span class="hljs-keyword">xor</span>    %eax,%eax    Demo a;   <span class="hljs-number">40068</span>d:   <span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">45</span> f0             lea    <span class="hljs-number">-0x10</span>(%rbp),%rax  <span class="hljs-number">400691</span>:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> c7                mov    %rax,%rdi  <span class="hljs-number">400694</span>:   e8 <span class="hljs-number">27</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          callq  <span class="hljs-number">4006</span>c0 &lt;_ZN4DemoC1Ev&gt;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-number">400699</span>:   b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          mov    $<span class="hljs-number">0x0</span>,%eax&#125;  <span class="hljs-number">40069</span>e:   <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">55</span> f8             mov    <span class="hljs-number">-0x8</span>(%rbp),%rdx  <span class="hljs-number">4006</span>a2:   <span class="hljs-number">64</span> <span class="hljs-number">48</span> <span class="hljs-number">33</span> <span class="hljs-number">14</span> <span class="hljs-number">25</span> <span class="hljs-number">28</span> <span class="hljs-number">00</span>    <span class="hljs-keyword">xor</span>    %fs:<span class="hljs-number">0x28</span>,%rdx  <span class="hljs-number">4006</span>a9:   <span class="hljs-number">00</span> <span class="hljs-number">00</span>   <span class="hljs-number">4006</span>ab:   <span class="hljs-number">74</span> <span class="hljs-number">05</span>                   je     <span class="hljs-number">4006b</span>2 &lt;main+<span class="hljs-number">0x3c</span>&gt;  <span class="hljs-number">4006</span>ad:   e8 ae fe ff ff          callq  <span class="hljs-number">400560</span> &lt;__stack_chk_fail@plt&gt;  <span class="hljs-number">4006b</span>2:   c9                      leaveq   <span class="hljs-number">4006b</span>3:   c3                      retq   <span class="hljs-number">00000000004006b</span>4 &lt;_ZN4Demo4funcEv&gt;:<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;&#125;  <span class="hljs-number">4006b</span>4:   <span class="hljs-number">55</span>                      push   %rbp  <span class="hljs-number">4006b</span>5:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                mov    %rsp,%rbp  <span class="hljs-number">4006b</span>8:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8             mov    %rdi,<span class="hljs-number">-0x8</span>(%rbp)  <span class="hljs-number">4006b</span>c:   <span class="hljs-number">90</span>                      nop  <span class="hljs-number">4006b</span>d:   <span class="hljs-number">5</span>d                      pop    %rbp  <span class="hljs-number">4006b</span>e:   c3                      retq     <span class="hljs-number">4006b</span>f:   <span class="hljs-number">90</span>                      nop<span class="hljs-number">00000000004006</span>c0 &lt;_ZN4DemoC1Ev&gt;:<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;</span>  <span class="hljs-number">4006</span>c0:   <span class="hljs-number">55</span>                      push   %rbp  <span class="hljs-number">4006</span>c1:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                mov    %rsp,%rbp  <span class="hljs-number">4006</span>c4:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8             mov    %rdi,<span class="hljs-number">-0x8</span>(%rbp)  <span class="hljs-number">4006</span>c8:   ba <span class="hljs-number">78</span> <span class="hljs-number">07</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>          mov    $<span class="hljs-number">0x400778</span>,%edx  <span class="hljs-number">4006</span>cd:   <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">45</span> f8             mov    <span class="hljs-number">-0x8</span>(%rbp),%rax</code></pre><p>可见，在类中有虚函数的时候，的确会生成默认构造函数并在<strong>main中Line 13</strong>进行了调用。<br />至于其他几种情况，如类有虚基类、非静态成员变量或直接基类生成了构造函数，才会生成默认构造函数。</p><hr /><h2 id="q2默认构造函数会初始化成员变量吗"><a class="markdownIt-Anchor" href="#q2默认构造函数会初始化成员变量吗"></a> Q2：默认构造函数会初始化成员变量吗？</h2><h2 id="a2不一定"><a class="markdownIt-Anchor" href="#a2不一定"></a> A2：不一定</h2><p>在C++05标准文档 Section 12.1.8 中有说明</p><blockquote><p>Default constructors are called implicitly to create class objects of static or automatic storage duration defined without an initialize.<br />默认构造函数，会在静态或自动存储期间被隐式调用，来创建类对象，没有初始化。</p></blockquote><p>默认构造不一定会设定每一个成员变量的默认值<br />默认构造函数只是为了满足编译器的需要，将类中需要构造的成员变量按声明的顺序依次构造出来，使程序能够运行，但未必会进行初始化！<br />在C++的设计中，对成员变量进行初始化这种，为了满足程序的需要，是程序员的责任。</p><h3 id="求证-2"><a class="markdownIt-Anchor" href="#求证-2"></a> 求证</h3><pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_a;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; m_a &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;   &#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Base A;    A.func();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>这段代码可以保证使用默认构造函数构造了对象A，然后调用func方法输出成员变量的值</p><pre class="highlight"><code class="c">jeremynancy@ubuntu:~/cpp/constructor$ g++ --versiong++ (Ubuntu <span class="hljs-number">5.4</span><span class="hljs-number">.0</span><span class="hljs-number">-6u</span>buntu1~<span class="hljs-number">16.04</span><span class="hljs-number">.1</span>) <span class="hljs-number">5.4</span><span class="hljs-number">.0</span> <span class="hljs-number">20160609</span>Copyright (C) <span class="hljs-number">2015</span> Free Software Foundation, Inc.This is <span class="hljs-built_in">free</span> software; see the source <span class="hljs-keyword">for</span> copying conditions.  There is NOwarranty; <span class="hljs-keyword">not</span> even <span class="hljs-keyword">for</span> MERCHANTABILITY <span class="hljs-keyword">or</span> FITNESS FOR A PARTICULAR PURPOSE.jeremynancy@ubuntu:~/cpp/constructor$ ./<span class="hljs-keyword">default</span>-value <span class="hljs-number">4196368</span></code></pre><p>编译运行之后发现是一个随机值，并没有初始化成零值，至少在图示中的这个版本g<ins>编译器中是这样的。<br />经过尝试，的确有些环境或版本下的某种编译器会自动把成员变量初始化成零值，但是这并不是C</ins>标准中要求编译器做的事情，所以应该这个初始化的职责应该由程序员来承担。</p><hr /><h2 id="q3一个类的构造过程中基类-成员变量和类本身构造函数调用的顺序编译器是如何实现的"><a class="markdownIt-Anchor" href="#q3一个类的构造过程中基类-成员变量和类本身构造函数调用的顺序编译器是如何实现的"></a> Q3：一个类的构造过程中，基类、成员变量和类本身构造函数调用的顺序？编译器是如何实现的？</h2><h2 id="a3"><a class="markdownIt-Anchor" href="#a3"></a> A3：</h2><ul><li><h3 id="调用顺序基类构造函数-成员变量构造函数-类本身构造函数"><a class="markdownIt-Anchor" href="#调用顺序基类构造函数-成员变量构造函数-类本身构造函数"></a> 调用顺序：基类构造函数 =&gt; 成员变量构造函数 =&gt; 类本身构造函数。</h3></li><li><h3 id="实现方式编译器通过在类的每个构造函数顶部进行填充以实现这个构造顺序"><a class="markdownIt-Anchor" href="#实现方式编译器通过在类的每个构造函数顶部进行填充以实现这个构造顺序"></a> 实现方式：编译器通过在类的每个构造函数顶部进行填充，以实现这个构造顺序。</h3></li></ul><p>对于下列类代码</p><pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><span class="hljs-keyword">public</span>:    Base() &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Base"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;   &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Member</span> &#123;</span><span class="hljs-keyword">public</span>:    Member() &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Member"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;   &#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<span class="hljs-keyword">public</span>:    Member m;    Demo() &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Demo"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;       Demo(<span class="hljs-keyword">int</span> x) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Demo 1"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;   &#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Demo A;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>Demo</strong> 类的每个构造函数在编译时会被扩张成如下</p><pre class="highlight"><code class="cpp">Demo::Demo() &#123;    <span class="hljs-comment">// 插入父类构造</span>    Base::Base()    <span class="hljs-comment">// 插入成员变量构造</span>    Member::Member()    <span class="hljs-comment">// 继续本身的处理</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Demo"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><h2 id="求证-3"><a class="markdownIt-Anchor" href="#求证-3"></a> 求证</h2><p>编译后反汇编查看无参构造函数</p><pre class="highlight"><code class="cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<span class="hljs-keyword">public</span>:    Member m;    Demo() &#123;  <span class="hljs-number">4009</span>a0:   <span class="hljs-number">55</span>                      push   %rbp  <span class="hljs-number">4009</span>a1:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> e5                mov    %rsp,%rbp  <span class="hljs-number">4009</span>a4:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">10</span>             sub    $<span class="hljs-number">0x10</span>,%rsp  <span class="hljs-number">4009</span>a8:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">7</span>d f8             mov    %rdi,<span class="hljs-number">-0x8</span>(%rbp)  <span class="hljs-number">4009</span>ac:   <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">45</span> f8             mov    <span class="hljs-number">-0x8</span>(%rbp),%rax  <span class="hljs-number">4009b</span>0:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> c7                mov    %rax,%rdi  <span class="hljs-number">4009b</span>3:   e8 <span class="hljs-number">90</span> ff ff ff          callq  <span class="hljs-number">400948</span> &lt;_ZN4BaseC1Ev&gt;  <span class="hljs-number">4009b</span>8:   <span class="hljs-number">48</span> <span class="hljs-number">8b</span> <span class="hljs-number">45</span> f8             mov    <span class="hljs-number">-0x8</span>(%rbp),%rax  <span class="hljs-number">4009b</span>c:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> c7                mov    %rax,%rdi  <span class="hljs-number">4009b</span>f:   e8 b0 ff ff ff          callq  <span class="hljs-number">400974</span> &lt;_ZN6MemberC1Ev&gt;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Demo"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  <span class="hljs-number">4009</span>c4:   be <span class="hljs-number">80</span> <span class="hljs-number">0</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span>          mov    $<span class="hljs-number">0x400a80</span>,%esi  <span class="hljs-number">4009</span>c9:   bf <span class="hljs-number">80</span> <span class="hljs-number">10</span> <span class="hljs-number">60</span> <span class="hljs-number">00</span>          mov    $<span class="hljs-number">0x601080</span>,%edi  <span class="hljs-number">4009</span>ce:   e8 <span class="hljs-number">9</span>d fd ff ff          callq  <span class="hljs-number">400770</span> &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;  <span class="hljs-number">4009</span>d3:   be a0 <span class="hljs-number">07</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>          mov    $<span class="hljs-number">0x4007a0</span>,%esi  <span class="hljs-number">4009</span>d8:   <span class="hljs-number">48</span> <span class="hljs-number">89</span> c7                mov    %rax,%rdi  <span class="hljs-number">4009</span>db:   e8 b0 fd ff ff          callq  <span class="hljs-number">400790</span> &lt;_ZNSolsEPFRSoS_E@plt&gt;    &#125;</code></pre><p>可见，在<strong>Demo::Demo</strong>构造函数原本的函数体之前，依次插入了Base类的构造函数 <strong>_ZN4BaseC1Ev</strong>，和Member类的构造函数 <strong>_ZN6MemberC1Ev</strong>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1804.pdf&quot;&gt;C++05标准文档&lt;/a&gt; 中 Section 12.1.5 关于默认构造函数的说明&lt;/p&gt;
&lt;blockquote&gt;
&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/categories/C/"/>
    
    
    <category term="C++语法" scheme="https://jeremyyvv.github.io/tags/C-%E8%AF%AD%E6%B3%95/"/>
    
    <category term="C++对象模型" scheme="https://jeremyyvv.github.io/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/C++/STL/%E7%AE%97%E6%B3%95/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/C++/STL/%E7%AE%97%E6%B3%95/</id>
    <published>2021-03-21T12:04:00.000Z</published>
    <updated>2021-03-21T12:46:31.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条款30确保目标区间足够大"><a class="markdownIt-Anchor" href="#条款30确保目标区间足够大"></a> 条款30：确保目标区间足够大</h2><p>首先了解标准库中的一个算法：</p><pre class="highlight"><code class="">template &lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;OutputIterator transform (InputIterator first1, InputIterator last1, OutputIterator result, UnaryOperation op);</code></pre><p><strong><code>transform</code><strong>将</strong><code>[first1, last1)</code><strong>区间中的每个元素，传入函数</strong><code>op</code></strong>，然后将返回的结果赋值给**<code>result</code>**所指向的元素<br />但是这个算法有一个非常容易错误的用法：</p><pre class="highlight"><code class="">transform(values.begin(), values.end(), results.end(), func);</code></pre><p>意在将**<code>values</code><strong>中的元素一一传入</strong><code>func()</code><strong>，然后将返回值依次放在</strong><code>results</code>**的末尾。</p><p>这个用法的错误在于，<strong><code>results.end()</code><strong>返回的迭代器及其之后并</strong>没有指向任何元素</strong>，这样只会<strong>给不存在的对象赋值</strong>。<br />正确的用法是使用**<code>back_inserter()</code>**.</p><pre class="highlight"><code class="">template &lt;class Container&gt;back_insert_iterator&lt;Container&gt; back_inserter(Container&amp; x);</code></pre><p>将容器作为**<code>back_inserter</code><strong>的参数可以</strong>获得指向该容器末尾的一个<code>back_insert_iterator</code><strong>，而这个末尾插入迭代器</strong>重载了赋值运算符**：</p><pre class="highlight"><code class="">back_insert_iterator&lt;_Container&gt;&amp; operator=(typename _Container::const_reference _Val)&#123;container-&gt;push_back(_Val);return (*this);&#125;</code></pre><p><strong>对这个迭代器赋值，即是向容器push_back一个元素</strong>。<br />所以正确的用法是这样：</p><pre class="highlight"><code class="">transform(values.begin(), values.end(), back_inserter(results), func);</code></pre><p>相对的，有尾插入就会有头插入，<strong><code>front_inserter()</code></strong>，赋值时会调用**<code>push_front</code><strong>，所以</strong>只能用在提供了该方法的<code>deque</code>和<code>list</code>容器上**<br /><strong><code>inserter()</code><strong>则允许结果插入容器中的任意位置。<br />无论何时你使用一个要求</strong>指定目的区间的算法</strong>，确保<strong>目的区间已经足够大</strong>或者在算法<strong>执行时可以增加大小</strong>。<br /><strong>如果你选择增加大小，就使用插入迭代器。</strong></p><hr /><h2 id="条款31了解各种和排序有关的选择"><a class="markdownIt-Anchor" href="#条款31了解各种和排序有关的选择"></a> 条款31：了解各种和排序有关的选择</h2><p>STL算法中用于排序的算法不止**<code>sort</code>**一个，本条款介绍了另外的几个：</p><pre class="highlight"><code class="">template &lt;class RandomAccessIterator&gt;void partial_sort (RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);</code></pre><p><strong><code>partial_sort</code><strong>将</strong><code>[first, last)</code><strong>区间中，最好的</strong><code>(middle - first)</code><strong>个元素，<strong>排好序</strong>放在容器的</strong><code>[first, middle)</code><strong>区间中，</strong><code>comp()</code><strong>是判断是否更好的方法。<br />即把</strong>最好的n个</strong>元素<strong>按顺序</strong>放在容器<strong>前面</strong>，<strong>其他的无序</strong>。<br />实现方式是通过<strong>堆排序</strong>时，每次建堆可以获得一个最佳元素，持续n次后，将一共获得的n个最好元素按顺序放在容器前面。</p><pre class="highlight"><code class="">template &lt;class RandomAccessIterator, class Compare&gt;void nth_element (RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);</code></pre><p><strong><code>nth_element</code><strong>这个算法和</strong><code>partial_sort</code><strong>类似，但是放在最前面的n个元素</strong>不进行排序</strong>。<br /><strong><code>sort</code></strong>、<strong><code>partial_sort</code></strong>、<strong><code>nth_element</code><strong>这三个算法都是</strong>不稳定</strong>的排序算法（即不能保证值相同的元素在排序前后的顺序）.<br /><strong>稳定</strong>的排序算法是**<code>stable_sort</code><strong>，因为使用的</strong>归并排序**。</p><pre class="highlight"><code class="">template &lt;class RandomAccessIterator, class Compare&gt;void stable_sort ( RandomAccessIterator first, RandomAccessIterator last,Compare comp );</code></pre><p>还有一个算法是**<code>partition</code>**:</p><pre class="highlight"><code class="">template &lt;class BidirectionalIterator, class UnaryPredicate&gt;BidirectionalIterator partition (BidirectionalIterator first,BidirectionalIterator last, UnaryPredicate pred);</code></pre><p><strong><code>partition()</code><strong>重排</strong><code>[first, last)</code><strong>区间中的元素，以使满足</strong><code>pred条件</code></strong>(使pred返回true)的元素都在区间的<strong>开头</strong>，并返回重排后<strong>第一个不满足pred条件</strong>的元素的迭代器。<br /><strong><code>stable_partition</code><strong>则是</strong><code>partition</code><strong>的稳定版本。<br />算法</strong><code>sort</code></strong>、<strong><code>stable_sort</code></strong>、<strong><code>partial_sort</code><strong>和</strong><code>nth_element</code><strong>需要随机访问迭代器，所以无法用于</strong><code>list</code></strong>，而**<code>list</code><strong>提供了专属的</strong><code>list::sort</code>**用于稳定排序。</p><hr /><h2 id="条款32如果确实需要删除元素则需要在remove这一类算法之后调用erase"><a class="markdownIt-Anchor" href="#条款32如果确实需要删除元素则需要在remove这一类算法之后调用erase"></a> 条款32.如果确实需要删除元素，则需要在remove这一类算法之后调用erase</h2><p>我在条款9中说明了**<code>std::remove</code><strong>所做的操作，它</strong>并不删除某个元素**，而是将<strong>不需被删除的</strong>元素放在容器的前端。<br />类似的算法还有**<code>unique</code><strong>，用于</strong>删除相邻的重复元素**，它也不真的删除相邻重复元素，而是将相邻的不重复元素放在容器的前端，最后返回一个<strong>指向边界的迭代器</strong>。<br />所以如果需要真的删除其它元素，应该在**<code>remove</code><strong>、</strong><code>unique</code><strong>后调用</strong><code>erase</code>**.</p><hr /><h2 id="条款33对包含指针的容器使用remove这一类算法时要特别小心"><a class="markdownIt-Anchor" href="#条款33对包含指针的容器使用remove这一类算法时要特别小心"></a> 条款33.对包含指针的容器使用remove这一类算法时要特别小心</h2><p>还是**<code>std::remove</code><strong>的问题，如果容器中的指针指向的是</strong>动态分配<strong>的内存，在调用</strong><code>remove</code><strong>时会导致一些指针丢失，导致</strong>内存泄漏**。<br />如果向容器中添加的是<strong>智能指针</strong>，那这个问题就不存在了，你可以放心的对容器使用**<code>erase-remove</code>**删除元素。</p><hr /><h2 id="条款34了解哪些算法要求使用排序的区间作为参数"><a class="markdownIt-Anchor" href="#条款34了解哪些算法要求使用排序的区间作为参数"></a> 条款34.了解哪些算法要求使用排序的区间作为参数</h2><p>搜索算法**<code>binary_search</code><strong>、</strong><code>lower_bound</code><strong>、</strong><code>upper_bound</code><strong>和</strong><code>equal_range</code><strong>(详见条款45)需要有序区间，因为它们使用</strong>二分法查找**。<br /><strong><code>set_union</code></strong>、<strong><code>set_intersection</code></strong>、**<code>set_difference</code><strong>和</strong><code>set_symmetric_difference</code>**都需要有序区间。</p><pre class="highlight"><code class="">template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;OutputIterator set_union (InputIterator1 first1, InputIterator1 last1,InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></pre><p><strong><code>set_union</code><strong>将两个有序区间中的元素</strong>合并</strong>，<strong>重复的元素只保留一份</strong>。</p><pre class="highlight"><code class="">template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;OutputIterator set_intersection (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></pre><p><strong><code>set_intersection</code><strong>将两个有序区间中</strong>共有的元素</strong>拷贝一份</p><pre class="highlight"><code class="">template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;OutputIterator set_difference (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></pre><p><strong><code>set_difference</code><strong>将区间</strong><code>[first1, last1)</code>中有</strong>但是区间**<code>[first2, last2)</code>中没有**的元素拷贝到result中。</p><pre class="highlight"><code class="">template &lt;class InputIterator1, class InputIterator2, class OutputIterator&gt;OutputIterator set_symmetric_difference (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result);</code></pre><p><strong><code>set_symmetric_difference</code><strong>将区间</strong><code>[first1, last1)</code>中有</strong>但是区间**<code>[first2, last2)</code>中没有**,与区间**<code>[first2, last2)</code>中有<strong>但是区间</strong><code>[first1, last1)</code>中没有<strong>的元素</strong>都<strong>拷贝到result中。<br />这四个算法要求</strong>有序<strong>区间，是为了保证</strong>线性时间复杂度**。</p><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;条款30确保目标区间足够大&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#条款30确保目标区间足够大&quot;&gt;&lt;/a&gt; 条款30：确保目标区间足够大&lt;/h2&gt;
&lt;p&gt;首先了解标准库中的一个算法：&lt;/p&gt;
&lt;pre class=&quot;highlig</summary>
      
    
    
    
    <category term="STL" scheme="https://jeremyyvv.github.io/categories/STL/"/>
    
    
    <category term="C++库" scheme="https://jeremyyvv.github.io/tags/C-%E5%BA%93/"/>
    
    <category term="语法" scheme="https://jeremyyvv.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>迭代器</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/C++/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/C++/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2021-03-21T12:03:00.000Z</published>
    <updated>2021-03-21T12:46:24.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条款26iterator优先于const_iterator-reverse_iterator及const_reverse_iterator"><a class="markdownIt-Anchor" href="#条款26iterator优先于const_iterator-reverse_iterator及const_reverse_iterator"></a> 条款26.iterator优先于const_iterator、reverse_iterator及const_reverse_iterator</h2><p><strong>先说这四种迭代器各自的功能</strong><br />对iterator进行递增可以从容器头部遍历到尾部<br />对reverse_iterator进行递增则可以从容器尾部遍历到头部<br />const_iterator和const_reverse_iterator则是对这两种迭代器增加了常量性，不可改变迭代器指向的值<br /><strong>再说它们之间的转换</strong>，为了直观一些我做了一张图<br /><img src="https://gitee.com/JeremyYv/pic-go/raw/master/20210118000508.PNG" alt="" /><br /><strong>这四个迭代器是四个毫无关联的类(!!)。</strong><br /><strong>可以通过隐式转换，将非const转换为const，但const无法直接转换为非const(具体方法见下一条款)。</strong><br /><strong>至于非reverse和reverse之间转换</strong>，书上说非reverse可以隐式转换为reverse，但在vs2005的STL实现中，<strong>已经由explicit声明为非隐式转换了，需要将iterator传入reverse_iterator的构造函数转换为reverse迭代器</strong>。<strong>而reverse转换为非reverse则可以通过迭代器调用base()获得</strong>。<br /><strong>最后可以说下这个条款了，<strong>为什么要优先使用iterator，避免使用其他三个<br /><strong>容器类中的很多成员函数形参类型都是iterator</strong>，包括运算符重载函数，传入其他三个无法隐式转换为iterator类型的迭代器，将无法通过编译。而且</strong>混用不同类型迭代器，将导致模板函数在类型推导时产生意料之外的编译问题</strong>。</p><hr /><h2 id="条款27使用distance和advance将容器的const_iterator转换成iterator"><a class="markdownIt-Anchor" href="#条款27使用distance和advance将容器的const_iterator转换成iterator"></a> 条款27.使用distance和advance将容器的const_iterator转换成iterator</h2><p>上一条款中提到，<strong><code>const_iterator</code>无法直接转换为<code>iterator</code></strong>。<br />如果想要转换，可以<strong>创建一个新的<code>iterator</code></strong>，先将它<strong>指向<code>begin()</code></strong>，然后<strong>计算<code>const_iterator</code>和<code>begin(</code>)之间的距离</strong>，再将新的迭代器移动相应距离，即可获得一个和**<code>const_iterator</code><strong>指向相同对象的</strong><code>iterator</code><strong>。<br />想法很简单很直接，实现通过</strong><code>distance()</code><strong>和</strong><code>advance()</code>**这两个函数</p><pre class="highlight"><code class="">template&lt;class InputIterator&gt;  typename iterator_traits&lt;InputIterator&gt;::difference_type    distance (InputIterator first, InputIterator last);    一长串的返回值可以忽略，这个函数返回两个迭代器之间的距离</code></pre><pre class="highlight"><code class="">template &lt;class InputIterator, class Distance&gt;  void advance (InputIterator&amp; it, Distance n);    将迭代器移动n个距离</code></pre><p>一起使用：</p><pre class="highlight"><code class="">const_iterator const_it = vec.begin();...//经过某些操作iterator it = vec.begin();advance(it, distance&lt;const_iterator&gt;(it, const_it));</code></pre><p>ps.因为**<code>distance()</code>进行类型推导时，迭代器实参需要类型一致**，所以通过**<code>&lt;const_iterator&gt;</code>指定模板推导类型**，<strong><code>iterator</code><strong>隐式转换为</strong><code>const_iterator</code></strong></p><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;条款26iterator优先于const_iterator-reverse_iterator及const_reverse_iterator&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#条款26iterator优先于const_iter</summary>
      
    
    
    
    <category term="STL" scheme="https://jeremyyvv.github.io/categories/STL/"/>
    
    
    <category term="C++库" scheme="https://jeremyyvv.github.io/tags/C-%E5%BA%93/"/>
    
    <category term="语法" scheme="https://jeremyyvv.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关联容器</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/C++/STL/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/C++/STL/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</id>
    <published>2021-03-21T12:02:00.000Z</published>
    <updated>2021-03-21T12:46:16.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条款19理解相等equality和等价equivalence的区别"><a class="markdownIt-Anchor" href="#条款19理解相等equality和等价equivalence的区别"></a> 条款19.理解相等(equality)和等价(equivalence)的区别</h2><p>标准关联容器需要保持有序，所以每个容器<strong>必须有一个定义了怎么保持东西有序的比较函数</strong>(默认是<code>less</code>)。<br />以set举例，<strong><code>set&lt;string*&gt; ssp</code></strong> 是 <strong><code>set&lt;string*, less&lt;string*&gt;, allocator&lt;string*&gt; &gt; ssp</code><strong>的简写。<br />第三个参数分配器不是这章讨论的问题。我们看第二个参数</strong><code>less&lt;string*&gt;</code></strong>,这是一个<strong>仿函数</strong>（通过重载类的()运算符，模仿函数的调用），是<strong>用于判断set中元素是否等价的比较函数</strong>。<br /><strong>等价不同于相等</strong>，是关联容器所引入的概念，即<strong>在排序顺序上，如果两个元素各自都不应该排在另一个的前面，则这两个元素是等价的</strong>。</p><p>在set类中，将比较函数<strong>typedef为<code>key_compare</code></strong>.<br /><strong>判断是否等价的判别式</strong>为**<code>!c.key_compare()(x, y) &amp;&amp; !c.key_compare()(y, x)</code><strong>.<br />当<code>keycompare()</code>为<code>less&lt;&gt;</code>时，<code>key_compare()(x,y)</code>只有在x不小于y时返回false，<code>key_compare()(y,x)</code>只有在y不小于x时返回false.<br />所以只有x和y相等时</strong>该判别式为true，视该两元素等价**，<strong>关联容器中不会保存两个等价的元素</strong>。</p><p>ps.set的第二个参数使用仿函数，是因为<strong>set模版第二个参数是数据类型</strong>，用于模板具现化，<strong>不接收函数指针</strong>。</p><hr /><h2 id="条款20为包含指针的关联容器指定比较类型"><a class="markdownIt-Anchor" href="#条款20为包含指针的关联容器指定比较类型"></a> 条款20.为包含指针的关联容器指定比较类型</h2><p>考虑下面这段代码，向一个set中放入指针对象</p><pre class="highlight"><code class="">set&lt;string*&gt; ssp; ssp.insert(new string(&quot;Anteater&quot;));ssp.insert(new string(&quot;Wombat&quot;));ssp.insert(new string(&quot;Lemur&quot;));ssp.insert(new string(&quot;Penguin&quot;));</code></pre><p>默认的比较函数会作用于指针值，即地址，<strong>将指针按地址大小排序</strong>，而不是根据指针所指向的内容进行排序<br />如果希望容器中根据指针所指向的内容排序，则需要为其指定<strong>特殊的比较函数</strong></p><pre class="highlight"><code class="">struct StringPtrLess:public binary_function&lt;const string*, const string*, bool&gt;&#123;bool operator()(const string *ps1, const string *ps2) const&#123;return *ps1 &lt; *ps2;&#125;&#125;;</code></pre><p>ps.继承自**<code>binary_function&lt;const string*, const string*, bool&gt;</code>**的原因详见条款40（<strong>该基类也是less&lt;&gt;的基类</strong>）<br />创建关联容器时指定该比较函数</p><pre class="highlight"><code class="">set&lt;string*, StringPtrLess&gt; ssp; </code></pre><p>然后这个容器内的元素就是按照指针所指向的元素进行排序了</p><p>ps.在输出时如果不想使用<code>**iter</code>，可以写一个输出函数<code>print</code>，使用<code>foreach()</code>，对每个元素调用<code>print</code></p><pre class="highlight"><code class="">void print(const string *ps)&#123;cout &lt;&lt; *ps &lt;&lt; endl;&#125;for_each(ssp.begin(), ssp.end(), print);</code></pre><hr /><h2 id="条款21总是让比较函数在等值情况下返回false"><a class="markdownIt-Anchor" href="#条款21总是让比较函数在等值情况下返回false"></a> 条款21.总是让比较函数在等值情况下返回false</h2><p>条款19中，<strong><code>less&lt;&gt;</code><strong>相当于&quot;&lt;&quot;,而</strong><code>less_equal&lt;&gt;</code><strong>相当于&quot;&lt;=&quot;，<br />如果比较函数</strong><code>key_compare</code><strong>指定为</strong><code>less_equal&lt;&gt;</code></strong>，则在判别式**<code>!c.key_compare()(x, y) &amp;&amp; !c.key_compare()(y, x)</code><strong>中，<br /><strong><code>!c.key_compare()(x,y)</code><strong>在x==y时返回false,</strong><code>!c.key_compare()(y,x)</code><strong>在x==y时也返回false,则</strong>判断为x,y不等价，</strong><br /><strong>set中就会插入值相等的x与y</strong>，这会</strong>破坏set的容器结构**。</p><hr /><h2 id="条款22切勿直接修改set或multiset中的键"><a class="markdownIt-Anchor" href="#条款22切勿直接修改set或multiset中的键"></a> 条款22.切勿直接修改set或multiset中的键</h2><p>本条款中没有一并提及<code>map</code>和<code>multimap</code>，因为**<code>map&lt;K,V&gt;</code><strong>中元素类型为</strong><code>pair&lt;const K, V&gt;</code><strong>，对键的更改无法通过编译。<br />而</strong>set和multiset用于排序的键可由迭代器访问更改其值**，这会<strong>破坏set中元素的有序性</strong>。<br />如果想要更改set中用于排序的键，应先通过迭代器将对象<strong>拷贝</strong>，再<strong>erase</strong>容器中的该元素，然后<strong>更改</strong>拷贝对象的键值，最将该拷贝<strong>insert</strong>入容器。</p><hr /><h2 id="条款23考虑用排序的vector替代关联容器"><a class="markdownIt-Anchor" href="#条款23考虑用排序的vector替代关联容器"></a> 条款23.考虑用排序的vector替代关联容器</h2><p><strong>map中单个元素占用的内存比vector中多</strong>，因为map要<strong>额外维护</strong>指向两个子节点和指向父节点的<strong>三个指针</strong>。<br />所以<strong>元素很多时map要比vector多占用很多内存</strong>。<br />如果程序中使用的容器只在很短的阶段进行数据的插入和删除，而<strong>大多数的阶段是在进行查询和修改，使用vector性能会更好</strong>。<br />容器完成插入阶段后，进行排序。<strong>有序容器可以正确地使用查找算法</strong>——<strong><code>binary_search</code>、<code>lower_bound</code>、<code>equal_range</code><strong>等（参见条款34）。<br />而且</strong>一个有序vector的二分法查找(通过下标访问)比一个二叉树的二分法查找(通过指针迭代)提供了更好的性能</strong>。</p><hr /><h2 id="条款24当效率至关重要时请在mapoperator与mapinsert之间谨慎做出选择"><a class="markdownIt-Anchor" href="#条款24当效率至关重要时请在mapoperator与mapinsert之间谨慎做出选择"></a> 条款24.当效率至关重要时，请在map::operator[]与map::insert之间谨慎做出选择</h2><p><strong><code>map::operator[]</code><strong>被设计为</strong>简化&quot;添加或更新&quot;功能</strong>。<br /><strong><code>map::operator[]</code><strong>会生成一个</strong>临时对象，只赋键值</strong>，insert入map中，无论是否已经有该键值了，insert都会返回**<code>pair&lt;iterator, bool&gt;</code><strong>对象，<br />这个返回值中的first变量会指向拥有该唯一键值的元素，然后</strong>将operator[]等号右侧的值赋给该变量**.<br />当<strong>map中已经有该键值时，operator[]性能不如insert</strong>，因为在构造时并没有给新的元素赋值，而是在<strong>构造之后</strong>赋的值。<br /><strong>如果你要更新已存在的map元素，operator[]更好，但如果你要增加一个新元素，insert则有优势。</strong></p><hr /><h2 id="条款25熟悉非标准的散列容器"><a class="markdownIt-Anchor" href="#条款25熟悉非标准的散列容器"></a> 条款25.熟悉非标准的散列容器</h2><p><strong>散列容器，即基于哈希表(Hash Table)实现的容器。</strong><br />本书作于2001年，当时C<ins>标准委员会标准委员为了不过度地推迟标准的完成，将散列容器放在了标准的下一个版本中。<br />即C</ins>11中，增加了散列容器**<code>unordered_set</code><strong>和</strong><code>unordered_map</code>**<br />散列容器中元素<strong>并不是有序的，所以并没有等价的概念</strong>，默认比较函数为<code>equal_to</code>。</p><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;条款19理解相等equality和等价equivalence的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#条款19理解相等equality和等价equivalence的区别&quot;&gt;&lt;/a&gt; 条款19.理解相等(equality)和等</summary>
      
    
    
    
    <category term="STL" scheme="https://jeremyyvv.github.io/categories/STL/"/>
    
    
    <category term="C++库" scheme="https://jeremyyvv.github.io/tags/C-%E5%BA%93/"/>
    
    <category term="语法" scheme="https://jeremyyvv.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>vector和string</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/C++/STL/vector%E5%92%8Cstring/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/C++/STL/vector%E5%92%8Cstring/</id>
    <published>2021-03-21T12:01:00.000Z</published>
    <updated>2021-03-21T12:46:08.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条款13vector和string优先于动态分配的数组"><a class="markdownIt-Anchor" href="#条款13vector和string优先于动态分配的数组"></a> 条款13.vector和string优先于动态分配的数组</h2><p>使用new来动态分配内存后有三项需要承担的责任，<strong>在使用完资源后通过delete释放内存，并与new的形式配对（delete or delete[]），以及确保只delete了一次</strong>。<br />或是出于开发效率或是出于其他原因，vector和string可以使你不必承担这些责任，<strong>vector和string会自己管理内存（RAII方法，详见Effective C++条款13）</strong>，当他们被析构时，会自动析构容器中元素的内存。<br />而且<strong>vector和string是功能完全的STL序列容器</strong>，有很多的成员方法、迭代器及<algorithm>中的算法都可以使用。</p><hr /><h2 id="条款14使用reserve来避免不必要的重新分配"><a class="markdownIt-Anchor" href="#条款14使用reserve来避免不必要的重新分配"></a> 条款14.使用reserve来避免不必要的重新分配</h2><p>说reserve之前需要先了解vector和string作为<strong>可变长度数组</strong>，是如何实现长度可变的。在这个问题上这两个容器是相同的，以下就以vector来说明。<br />在vector被创建出来时，它占有一定大小的内存，这个大小由STL的实现方式决定。<br /><strong>每当需要更多空间时，它会重新申请一片原来两倍大的内存</strong>（在大多数实现中是这样），<strong>然后将容器内的所有元素从旧内存拷贝到新内存中，然后析构掉旧内存中的对象并释放旧内存。</strong><br />可以想象，每次改变长度这一系列操作，尤其是长度已经很长时，是很耗时的，而且这一操作可能发生在任何一次添加元素时。<br />所以如果你想创建一个vector<int>，并向其中放入1000个随机数，你可能会通过循环，将数一一push_back放入其中。那么在这个过程中，这个vector可能进行了7-8或者更多次内存申请及拷贝（这要取决于STL实现方式了），最先放入其中的数也被无效拷贝了7-8次，那么现在可以说说reserve了。</p><pre class="highlight"><code class="">void reserve (size_type n);    用于请求改变容器的现有长度。    如果实参n大于现有容器capacity()，容器会重新申请长度为n个元素长度的内存进行拷贝，否则不会发生任何事。</code></pre><p>所以在已知要放入1000个元素时，<strong>可以在放入元素之前，先通过reserve()将容器的内存长度改变为1000个元素的内存长度，再向其中放入元素，这样在push_back的过程中不会发生长度改变，也就不会执行上述无效的内存拷贝</strong>。<br />当然，可以在一开始多申请一些预留空间，至于多余的容量如何去除，详见条款17.</p><hr /><h2 id="条款15注意string实现的多样性"><a class="markdownIt-Anchor" href="#条款15注意string实现的多样性"></a> 条款15.注意string实现的多样性</h2><p><strong>string有很多种常见的实现方式</strong>，但几乎每个实现版本都包含以下信息：<br />字符串的<strong>大小</strong>(size)、<strong>容量</strong>(capacity)和<strong>值</strong>(即构成该字符串的字符)，可能还会有<strong>分配器</strong>的拷贝(allocator)和对值的<strong>引用计数</strong>。<br />这些成员的存储结构决定了string的大小，了解string的实现多样性，然后在应当忽略细节时忽略，应该考虑时考虑。</p><hr /><h2 id="条款16了解如何把vector和string数据传给旧的api"><a class="markdownIt-Anchor" href="#条款16了解如何把vector和string数据传给旧的api"></a> 条款16.了解如何把vector和string数据传给旧的API</h2><p>vector中的元素是<strong>存储在连续的内存中</strong>，就像数组一样，所以可以通过**<code>&amp;v[0]</code><strong>获取指向第一个元素的指针。<br />而string中的数据</strong>不一定存储在连续的内存中**，要通过成员函数**<code>c_str()</code>**获取指向字符串值的指针.</p><hr /><h2 id="条款17使用swap技巧除去多余的容量"><a class="markdownIt-Anchor" href="#条款17使用swap技巧除去多余的容量"></a> 条款17.使用“swap技巧”除去多余的容量</h2><p>这条是接着条款14说。<br /><strong>vector的构造函数有一个特点，会以被拷贝的vector.size()申请自己新的内存大小。</strong><br />所以可以通过**<code>vector&lt;type&gt;(OldVec)</code><strong>将旧vector中的元素拷贝到新的容器中，且</strong>新的容器容量为元素的个数**。<br />然后通过**<code>vector::swap()</code>**将新旧vector数据交换，即完成了将旧vector中多余容量的除去。</p><pre class="highlight"><code class="">vector&lt;type&gt;(OldVec).swap(OldVec);    用于除去多余容量的swa技巧</code></pre><p><strong>同样的技巧对string适用。</strong><br />题外话，swap技巧也可以用来清除容器并释放空间</p><pre class="highlight"><code class="">vector&lt;type&gt;().swap(OldVec);    用于清除容器</code></pre><p>我看了下，和vector::clear()的区别是clear()不将容量清空。</p><hr /><h2 id="条款18避免使用vectorbool"><a class="markdownIt-Anchor" href="#条款18避免使用vectorbool"></a> 条款18.避免使用vector&lt;bool&gt;</h2><p>现在的vector&lt;bool&gt;是一个历史实验的失败产物。<br />bool类型的值无非真或假(1或0)，所以1个bit位就可以保存，而不需要1整个字节(8bit),<br />所以C<ins>标准委员会在vector&lt;bool&gt;的实现中尝试了**代理对象(详见More Effective C</ins> 条款30)<strong>，<br />即将8个bool值保存在1个字节中，</strong><code>vector&lt;boo&gt;::operator[]</code><strong>返回的是一个</strong>代理对象的引用**，这个代理对象表现的像一个正常的bool对象，但这个代理对象的类型是**<code>vector&lt;bool&gt;::reference</code><strong>。所以你</strong>无法将一个bool类型的指针指向vector&lt;bool&gt;中第一个元素的地址，这将导致很多模板不能正常使用**。<br /><strong>一个替代的方案是deque&lt;bool&gt;</strong>，但deque在内存中不是连续的，无法完成条款16中所述任务。<br /><strong>另一个替代的方案是std::bitset</strong>,它与vector&lt;bool&gt;存储bool值的方式相同，<strong>区别在于，它不是个STL容器，不会引起模版的误用</strong>。</p><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;条款13vector和string优先于动态分配的数组&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#条款13vector和string优先于动态分配的数组&quot;&gt;&lt;/a&gt; 条款13.vector和string优先于动态分配的数组&lt;/h2&gt;</summary>
      
    
    
    
    <category term="STL" scheme="https://jeremyyvv.github.io/categories/STL/"/>
    
    
    <category term="C++库" scheme="https://jeremyyvv.github.io/tags/C-%E5%BA%93/"/>
    
    <category term="语法" scheme="https://jeremyyvv.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>容器</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/C++/STL/%E5%AE%B9%E5%99%A8/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/C++/STL/%E5%AE%B9%E5%99%A8/</id>
    <published>2021-03-21T12:00:00.000Z</published>
    <updated>2021-03-21T12:45:58.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="条款1-慎重选择容器类型"><a class="markdownIt-Anchor" href="#条款1-慎重选择容器类型"></a> 条款1. 慎重选择容器类型</h2><p><strong>标准STL序列容器</strong>：vector、string、deque和list<br /><strong>标准STL关联容器</strong>：set、map、multiset和multimap<br /><strong>非标准的关联容器</strong>：hash_set、hash_multiset、hash_map和hash_multimap<br /><strong>标准的非STL容器</strong>：数组、bitset、valarray、stack、queue和priority_queue</p><p>另一种分类：<br /><strong>连续内存容器</strong>(元素存放在一块或多块内存中，每块内存中存有多个元素)：vector、string和deque<br /><strong>基于节点的容器</strong>(每块内存存放一个元素)：list和所有标准的关联容器</p><hr /><h2 id="条款2-不要试图编写独立于容器类型的代码"><a class="markdownIt-Anchor" href="#条款2-不要试图编写独立于容器类型的代码"></a> 条款2. 不要试图编写独立于容器类型的代码</h2><p>序列容器与关联容器数据结构不同 ，<strong>所提供的操作也不同</strong>。<br />序列容器支持<code>push_front</code>或<code>push_back</code>，但关联容器不支持。<br />关联容器提供对数时间复杂度的<code>lower_bound</code>、<code>upper_bound</code>和<code>equal_range</code>成员函数，但序列容器却没有。<br />写既要和序列容器又要和关联容器一起工作的代码并没有什么意义。<strong>很多成员函数(包括运算符重载)只存在于其中一类容器中</strong>。</p><hr /><h2 id="条款3-确保容器中的对象拷贝正确且高效"><a class="markdownIt-Anchor" href="#条款3-确保容器中的对象拷贝正确且高效"></a> 条款3. 确保容器中的对象拷贝正确且高效</h2><p>当你向容器中添加一个对象（比如通过<code>insert</code>或<code>push_back</code>等），进入容器的是你指定的对象的<strong>拷贝</strong>，<br />如果你从vector、string或deque中插入或删除了什么或使用了任何排序算法，现有的<strong>容器元素会移动（拷贝）</strong>。<br />因此把一个派生类对象插入基类对象的容器会导致派生部分被删除，而且容器中如果放的对象拷贝过程很昂贵，<strong>元素的移动会成为性能瓶颈</strong>，<br />所以使拷贝更高效、正确而且对分割问题免疫的简单的方式是<strong>建立指针的容器而不是对象的容器</strong>。但是指针容器也有自己的问题，详见条款7和条款33。</p><hr /><h2 id="条款4-调用empty而不是检查size是否为0"><a class="markdownIt-Anchor" href="#条款4-调用empty而不是检查size是否为0"></a> 条款4. 调用empty()而不是检查size()是否为0</h2><p><strong>empty的典型实现是一个返回<code>size()==0</code>结果的内联函数</strong>。<br />对于所有的标准容器，<strong>empty是一个常数时间的操作</strong>，但对于一些list实现，<strong>size花费线性时间</strong>。<br /><strong>list中有一个变量用于记录元素个数</strong>。特殊的是，<code>list::splice()</code>用于拼接两个list，为了达到splice的高效率，<strong>在splice时可能不更新size</strong>，而在<strong>调用size时遍历list计算size</strong>，<br />这就会导致size()花费线性时间而不是常数时间。<br />但书中没有说empty()为什么一定是常数时间。<br />所以我看了下我所用的QT中list::empty()的实现方式，发现<strong>list是由循化链表实现的</strong>，<strong>empty()的实现是判断头节点的下个节点是否还是头结点，因此为常数时间</strong>。<br />所以我的理解是：<strong>由于STL的实现方式不同，<code>empty()</code>的效率比<code>0 == size()</code>更加稳定(如循环链表实现的List)。</strong></p><hr /><h2 id="条款5-区间成员函数优先于与之对应的单元素成员函数"><a class="markdownIt-Anchor" href="#条款5-区间成员函数优先于与之对应的单元素成员函数"></a> 条款5. 区间成员函数优先于与之对应的单元素成员函数</h2><p>本文以<code>insert</code>的单元素版本和区间版本说明，区间成员函数优点有三：</p><ol><li><strong>省去了没有必要的函数调用</strong>，调用1次与调用n次，即使将单元素版本声明为内联，也有可能不会成为内联。</li><li>每次<code>insert</code>单元素，<strong>要将插入位置后的所有元素进行移动</strong>，进行拷贝，区间<code>insert</code>则先算好一共要插入的总数，然后将插入位置后的元素<strong>只整体挪动一次</strong></li><li>看原因3前需要先看Part2.条款14中，了解序列容器插入元素时内存的重新分配机制。<strong>多次插入单元素可能导致内存多次重新分配</strong>，而<strong>区间插入则一次性分配足够的空间</strong>，然后进行插入。</li></ol><p><strong>常用区间成员函数整理：</strong><br />区间构造：</p><pre class="highlight"><code class="">container::container(InputIterator begin, InputIterator end); begin和end为旧容器中，被拷贝区间的起始</code></pre><p>区间插入：</p><pre class="highlight"><code class="">序列容器：void container::insert(iterator position,InputIterator begin, InputIterator end); 关联容器：void container::insert(lnputIterator begin, InputIterator end);//关联容器使用自己的比较函数决定插入元素放在哪begin和end为旧容器中，要插到新容器中的区间起始position为新容器中，要插入位置的迭代器，新元素插入到该迭代器之前</code></pre><p>区间删除：</p><pre class="highlight"><code class="">C++11以上: iterator container::erase(iterator begin, iterator end);C++11以下: 关联容器erase()返回值void将容器中[begin, end)前闭后开区间内的元素删除</code></pre><p>区间赋值：</p><pre class="highlight"><code class="">void container::assign(InputIterator begin, InputIterator end);begin和end为旧容器中，被拷贝区间的起始</code></pre><hr /><h2 id="条款6当心c编译器最烦人的分析机制"><a class="markdownIt-Anchor" href="#条款6当心c编译器最烦人的分析机制"></a> 条款6.当心C++编译器最烦人的分析机制</h2><p>按照条款5中所说，尝试使用list的区间构造，以一个文件中的全部内容构造一个list对象data</p><pre class="highlight"><code class="">ifstream dataFile(&quot;ints.dat&quot;);list&lt;int&gt; data(istream_iterator&lt;int&gt;(dataFile), istream_iterator&lt;int&gt;());</code></pre><p>上面这段代码乍一看好像没有问题，从文件的begin开始，一直迭代到NULL，即文件末尾，以此区间内的元素构造对象data。<br />但是编译器会将第二句代码<strong>解析为一个函数声明</strong>。<strong>问题出在构造时使用了一个匿名迭代器</strong>。<br />目前最好的解决方式，是<strong>在数据声明中避免使用匿名迭代器对象</strong>。</p><pre class="highlight"><code class="">ifstream dataFile(&quot;ints.dat&quot;);istream_iterator&lt;int&gt; dataBegin(dataFile);istream_iterator&lt;int&gt; dataEnd;list&lt;int&gt; data(dataBegin, dataEnd);</code></pre><hr /><h2 id="条款7如果在容器中包含了通过new操作创建的指针切记在容器对象析构前将指针delete掉"><a class="markdownIt-Anchor" href="#条款7如果在容器中包含了通过new操作创建的指针切记在容器对象析构前将指针delete掉"></a> 条款7.如果在容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉</h2><p>可以通过遍历容器释放指针，这样做能行，但不是异常安全的。<br />如果在向容器中放入和释放指针时有异常抛出，同样会有资源泄露。<br />所以最安全的做法是<strong>用引用计数智能指针（如Boost::shared_ptr）容器代替指针容器。</strong><br /><strong>ps.不要创建auto_ptr的容器，并指望其中的指针被自动删除，详见下一条款</strong></p><hr /><h2 id="条款8切勿创建包含auto_ptr的容器对象"><a class="markdownIt-Anchor" href="#条款8切勿创建包含auto_ptr的容器对象"></a> 条款8.切勿创建包含auto_ptr的容器对象</h2><p><strong>auto_ptr最大的古怪在于它的拷贝构造和赋值操作符，会将被拷贝的指针置为NULL。</strong><br />STL算法中的<strong>sort()<strong>采用的快速排序算法，会用临时对象拷贝vector中的值作为基准值。<br />这将导致</strong>vector&lt;auto_ptr&gt;调用sort()时，其中的值被临时对象拷贝，vector中的值被置为NULL，临时对象在作用域结束时释放了该auto_ptr</strong>。<br />**ps.**C<ins>标准委员会做了很多使vector&lt;auto_ptr&gt;不被编译通过，并最终在C</ins>11中移除了auto_ptr.</p><hr /><h2 id="条款9慎重选择删除元素的方法"><a class="markdownIt-Anchor" href="#条款9慎重选择删除元素的方法"></a> 条款9.慎重选择删除元素的方法</h2><h3 id="911-对于连续内存的容器vector-deuqe和string删除元素的最好办法是使用erase-remove"><a class="markdownIt-Anchor" href="#911-对于连续内存的容器vector-deuqe和string删除元素的最好办法是使用erase-remove"></a> 9.1.1. 对于连续内存的容器(vector、deuqe和string)，删除元素的最好办法是使用erase-remove</h3><pre class="highlight"><code class="">vec.erase( std::remove(vec.begin(), vec.end(), value), vec.end());</code></pre><p><strong>erase-remove讲解</strong>：先要说一下erase和remove，</p><pre class="highlight"><code class="">std::remove (Itertor first, Itertor last, const T&amp; val);    是&lt;algorithm&gt;中的算法，通过传入的迭代器确定容器遍历区间，将区间中不等于val的元素依次拷贝到区间中的前端。    完成遍历之后即确定了一段由first起始，没有val值的新区间，    最后返回该新区间后一个位置的迭代器</code></pre><pre class="highlight"><code class="">iterator erase (iterator first, iterator last);    将前开后闭区间[first, last)中的元素删除，返回last</code></pre><pre class="highlight"><code class="">erase-remove:    先通过remove将容器遍历，将不等于value值的元素放在容器前端新区间    再将新区间后一个位置的迭代器和容器的end()传入erase，将新区间以外的部分删除</code></pre><h3 id="912-对于listerase-remove同样适用但listremove更有效详见条款44"><a class="markdownIt-Anchor" href="#912-对于listerase-remove同样适用但listremove更有效详见条款44"></a> 9.1.2. 对于list，erase-remove同样适用，但list::remove()更有效(详见条款44)</h3><pre class="highlight"><code class="">list.remove(value);从list中移除所有值等于value的元素</code></pre><h3 id="913-对于关联容器set-multiset-map-multimap删除元素正确且高效的方法是调用erase高效的原因详见条款19不要对关联容器使用stdremove详见条款22"><a class="markdownIt-Anchor" href="#913-对于关联容器set-multiset-map-multimap删除元素正确且高效的方法是调用erase高效的原因详见条款19不要对关联容器使用stdremove详见条款22"></a> 9.1.3. 对于关联容器(set、multiset、map、multimap)，删除元素正确且高效的方法是调用erase（高效的原因详见条款19），不要对关联容器使用std::remove（详见条款22）</h3><pre class="highlight"><code class="">set.erase(value);从set中删除所有值为value的元素（multiset中也是删除所有）</code></pre><p><strong>ps.书中提到，序列容器erase会返回下一个位置的迭代器，而关联容器erase返回void，所以序列容器可以通过<code>iter = vec.erase(iter)</code>获得erase后有效的迭代器，而关联容器则要通过<code>set.erase(iter++)</code>后置++的方式获得。</strong><br />不过我在QtCreator和VisualStudio2005两个编译器都试了下，<strong>关联容器erase的返回值已经是下一个元素的迭代器</strong>了，两种容器可以都通过<code>iter = vec.erase(iter)</code>有效迭代，但对于序列容器不要使用<code>vec.erase(iter++)</code>,因为<strong>序列容器调用erase后，会使被删除元素之后所有的迭代器失效</strong>（虽然QtCreator对此有优化，但在visual studio中的确如此，还是不要这么使用的好）。</p><h3 id="92-要删除容器中满足特定判别式的所有对象序列容器使用erase-remove_iflist使用listremove_if关联容器使用遍历erase没有erase_if"><a class="markdownIt-Anchor" href="#92-要删除容器中满足特定判别式的所有对象序列容器使用erase-remove_iflist使用listremove_if关联容器使用遍历erase没有erase_if"></a> 9.2. 要删除容器中满足特定判别式的所有对象，序列容器使用erase-remove_if，list使用list::remove_if，关联容器使用遍历+erase(没有erase_if)</h3><pre class="highlight"><code class="">bool badvalue(int); //特定判别式</code></pre><pre class="highlight"><code class="">vec.erase( std::remove_if( vec.begin(),  vec.end(),  badvalue));    序列容器，遍历vec，删除使badvalue返回true的对象</code></pre><pre class="highlight"><code class="">list.remove_if(badvalue);    list::remove_if是删除使badvalue返回true的对象的最好办法</code></pre><pre class="highlight"><code class="">for(auto iter = set.begin(); iter != set.end(); /*for第三个参数什么也不做*/)&#123;    if(badvalue(*i))  set.erase(iter++);    else  ++iter;&#125;</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;条款1-慎重选择容器类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#条款1-慎重选择容器类型&quot;&gt;&lt;/a&gt; 条款1. 慎重选择容器类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;标准STL序列容器&lt;/strong&gt;：vector、string、</summary>
      
    
    
    
    <category term="STL" scheme="https://jeremyyvv.github.io/categories/STL/"/>
    
    
    <category term="C++库" scheme="https://jeremyyvv.github.io/tags/C-%E5%BA%93/"/>
    
    <category term="语法" scheme="https://jeremyyvv.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>状态模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:59:32.000Z</published>
    <updated>2021-03-21T12:46:43.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="状态模式一种行为型设计模式"><a class="markdownIt-Anchor" href="#状态模式一种行为型设计模式"></a> 状态模式：一种行为型设计模式</h3><ul><li><strong>应用场景：</strong><br />状态模式主要应用于对象有很多状态，每种状态下有不同的表现，而且在程序运行过程中会频繁变化状态，进而变化变现的情景。(<strong>程序运行过程中是否会频繁变化状态</strong>，是状态模式与策略模式本质上的区别)</li><li><strong>举例：</strong><br />以一个钟表举例，假设其有4种状态，上午、下午、傍晚和午夜模式，不同的模式下灯光显示不同。<br />比较简单的实现方式是使用枚举，在钟表的展示方法中通过枚举判断当前的模式，然后调用该模式对应的显示方法。<br />但是如果状态很多，判断枚举类型时的if-else或switch-case会很庞大，而且难于维护。<br />此时可以考虑将每种状态对应的表现封装成一个状态类，所有状态类继承自同一个基类，并提供统一的展示接口。<br />然后在钟表类中保存一个状态指针，通过设置该状态指针，调用不同状态类的展示接口。<br />这种消除分支语句的方式，和工厂模式类似。</li><li><strong>实现方式：</strong><br />状态基类中提供统一设置状态与展示的接口。<br />各状态类中重写展示接口，实现各自的展示方法。<br />钟表类中保存一个状态类对象的指针，钟表展示时调用该状态类指针的展示方法。</li></ul><hr /><h1 id="状态模式的简单代码实现"><a class="markdownIt-Anchor" href="#状态模式的简单代码实现"></a> 状态模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span>;</span><span class="hljs-comment">//时钟的状态属性</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateForClock</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(Clock* pClock)</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">//时钟类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span>&#123;</span><span class="hljs-keyword">public</span>:    Clock(): m_pState(<span class="hljs-literal">NULL</span>)&#123;&#125;    ~Clock()    &#123;        <span class="hljs-keyword">if</span>(m_pState)        &#123;            <span class="hljs-keyword">delete</span> m_pState;            m_pState = <span class="hljs-literal">NULL</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetState</span><span class="hljs-params">(StateForClock* pState)</span>    </span>&#123;        <span class="hljs-keyword">if</span>(!m_pState)        &#123;            <span class="hljs-keyword">delete</span> m_pState;        &#125;        m_pState = pState;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span>    </span>&#123;        m_pState-&gt;Show(<span class="hljs-keyword">this</span>);    &#125;<span class="hljs-keyword">private</span>:    StateForClock* m_pState;&#125;;<span class="hljs-comment">//午夜状态</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MidNightState</span>:</span><span class="hljs-keyword">public</span> StateForClock&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(Clock* pClock)</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"MidNight Mode"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//上午状态</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoonState</span>:</span><span class="hljs-keyword">public</span> StateForClock&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(Clock* pClock)</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"Noon Mode"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//下午状态</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterNoonState</span>:</span><span class="hljs-keyword">public</span> StateForClock&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(Clock* pClock)</span>    </span>&#123;         <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"AfterNoon Mode"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//晚上状态</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NightState</span>:</span><span class="hljs-keyword">public</span> StateForClock&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(Clock* pClock)</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"Night Mode"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Clock oClock;    oClock.SetState(<span class="hljs-keyword">new</span> NoonState());    oClock.Show();    oClock.SetState(<span class="hljs-keyword">new</span> AfterNoonState());    oClock.Show();    oClock.SetState(<span class="hljs-keyword">new</span> MidNightState());    oClock.Show();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="">Noon ModeAfterNoon ModeMidNight Mode</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;状态模式一种行为型设计模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#状态模式一种行为型设计模式&quot;&gt;&lt;/a&gt; 状态模式：一种行为型设计模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;br /&gt;
状态模</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="行为型" scheme="https://jeremyyvv.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:58:32.000Z</published>
    <updated>2021-03-21T12:46:47.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li><strong>中介者模式：一种行为型设计模式</strong></li><li><strong>应用场景：</strong><br />一般来说，大型的软件在开发的过程中会使用<strong>模块化</strong>的开发方式。以我现在参与的项目举例，完整的软件包括交互、检索、算路、引导等等多个模块，这样有利于模块之间的<strong>独立</strong>开发，提高整体开发效率。<br />但是无论模块之间如何独立，总是会有需要模块间通信的时候。<br />例如用户通过界面交互，发起检索，这个过程需要交互与检索两模块间通信，将用户的意图由交互模块传递至检索模块。<br />这就会产生一个<strong>扩展性</strong>上的问题。如果模块有很多，且每个模块都向外提供了<strong>唯一</strong>的接收消息的接口，那么一个模块如果需要与其他所有模块通信，则需要记录其他所有模块的通信接口，同理<strong>每个模块都要记录所有与自己相关联的模块的通信接口</strong>。首先这就是一件很冗余并降低开发效率的事情。<br />其次，一旦有一天，某个模块修改了自己所提供的通信接口，或者<strong>增加</strong>了一个新模块，尤其是后者，在公司项目发展过程中是很正常的事情。那么<strong>所有模块关于其他模块通信接口的记录可能都需要修改或增加</strong>，这在拥有庞大模块数量的项目中，是很恐怖的事情。<br />此时可以考虑<strong>中介者模式</strong>。</li><li><strong>举例：</strong><br />假设现在有3个模块<code>A B C</code>，<code>MessageAB</code>是<code>A B</code>间双向传递的一个消息，同理还有<code>MessageAC、MessageBC</code>。<br />引入一个中介者，它手中记录着各模块的<strong>通信接口</strong>与<strong>通信协议</strong>，协议即是一种<strong>约定</strong>，<code>A B</code>两模块间约定通过<code>MessageAB</code>来传递某种信息，即是这两模块间的一个<strong>协议</strong>。模块间通信都将消息发给中介者，中介者无需关注消息具体用来传递什么信息，只需要关注协议双方，通过正确的通信接口转发消息，确保消息的<strong>转发对象正确</strong>即可，而消息的解析处理在接收模块内部进行。<br />这样如果有通信接口修改或增加新模块，<strong>协议双方将新协议告知中介者记录即可</strong>。</li><li><strong>实现方式：</strong><br />中介者对象中需要保存所有需转发消息的模块指针作为成员变量。<br />各模块类中也需要保存负责转发消息的中介者指针作为成员变量。<br />各模块类中需要实现发送与接收消息的方法。<strong>模块发送消息时调用中介者的转发接口，中介者确定接收目标后调用目标的接收接口</strong>。<br />下面代码中为了简化协议，我统一了各模块接收消息的接口名称。</li></ul><hr /><h1 id="中介者模式的简单代码实现"><a class="markdownIt-Anchor" href="#中介者模式的简单代码实现"></a> 中介者模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">/* * 约定三种协议 * MessageAB是AB模块间通信的消息 * MessageAC是AC模块间通信的消息 * MessageBC是BC模块间通信的消息 */</span><span class="hljs-keyword">enum</span> Message&#123;    MessageAB,    MessageAC,    MessageBC,&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModuleBase</span>;</span><span class="hljs-comment">//中介者基类，提供转发接口</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediatorBase</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Transmit</span><span class="hljs-params">(Message enMessage, ModuleBase* pFrom)</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">//模块基类，实现向外发消息的方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModuleBase</span>&#123;</span><span class="hljs-keyword">public</span>:    ModuleBase(MediatorBase* pMediator):m_pMediator(pMediator)&#123;&#125;    <span class="hljs-comment">//模块向外发消息的方法</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendMessage</span><span class="hljs-params">(Message enMessage)</span>    </span>&#123;        m_pMediator-&gt;Transmit(enMessage, <span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-comment">//模块接收消息的接口，由模块自己实现</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vNotify</span><span class="hljs-params">(Message enMessage)</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-keyword">protected</span>:    <span class="hljs-comment">//每个模块内都有一份负责分发消息的中介者</span>    MediatorBase* m_pMediator;&#125;;<span class="hljs-comment">//模块A</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModuleA</span> :</span> <span class="hljs-keyword">public</span> ModuleBase&#123;<span class="hljs-keyword">public</span>:    ModuleA(MediatorBase* pMediator):ModuleBase(pMediator)&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vNotify</span><span class="hljs-params">(Message enMessage)</span>    </span>&#123;        <span class="hljs-keyword">switch</span>(enMessage)        &#123;        <span class="hljs-keyword">case</span> MessageAB:            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ModuleA get MessageAB from ModuleB"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> MessageAC:            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ModuleA get MessageAC from MoudleC"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;;<span class="hljs-comment">//模块B</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModuleB</span> :</span> <span class="hljs-keyword">public</span> ModuleBase&#123;<span class="hljs-keyword">public</span>:    ModuleB(MediatorBase* pMediator):ModuleBase(pMediator)&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vNotify</span><span class="hljs-params">(Message enMessage)</span>    </span>&#123;        <span class="hljs-keyword">switch</span>(enMessage)        &#123;        <span class="hljs-keyword">case</span> MessageAB:            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ModuleB get MessageAB from ModuleA"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> MessageBC:            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ModuleB get MessageBC form ModuleC"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;;<span class="hljs-comment">//模块C</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModuleC</span> :</span> <span class="hljs-keyword">public</span> ModuleBase&#123;<span class="hljs-keyword">public</span>:    ModuleC(MediatorBase* pMediator):ModuleBase(pMediator)&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">vNotify</span><span class="hljs-params">(Message enMessage)</span>    </span>&#123;        <span class="hljs-keyword">switch</span>(enMessage)        &#123;        <span class="hljs-keyword">case</span> MessageAC:            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ModuleC get MessageAC from ModuleA"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> MessageBC:            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ModuleC get MessageBC form ModuleB"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;;<span class="hljs-comment">//中介者实现类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteMediator</span> :</span> <span class="hljs-keyword">public</span> MediatorBase&#123;<span class="hljs-keyword">public</span>:    ConcreteMediator():m_pModA(<span class="hljs-literal">NULL</span>),m_pModB(<span class="hljs-literal">NULL</span>),m_pModC(<span class="hljs-literal">NULL</span>)&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Transmit</span><span class="hljs-params">(Message enMessage, ModuleBase* pFrom)</span>    </span>&#123;        <span class="hljs-keyword">switch</span>(enMessage)        &#123;        <span class="hljs-keyword">case</span> MessageAB:            &#123;                ModuleA* pFromWhere = <span class="hljs-keyword">dynamic_cast</span>&lt;ModuleA*&gt;(pFrom);                <span class="hljs-comment">//能通过dynamic_cast转换为不为NULL的指针,可确认指针指向的子类类型</span>                <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != pFromWhere)                &#123;                    m_pModB-&gt;vNotify(enMessage);                &#125;                <span class="hljs-keyword">else</span>                &#123;                    m_pModA-&gt;vNotify(enMessage);                &#125;            &#125;            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> MessageAC:            &#123;                ModuleA* pFromWhere = <span class="hljs-keyword">dynamic_cast</span>&lt;ModuleA*&gt;(pFrom);                <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != pFromWhere)                &#123;                    m_pModC-&gt;vNotify(enMessage);                &#125;                <span class="hljs-keyword">else</span>                &#123;                    m_pModA-&gt;vNotify(enMessage);                &#125;            &#125;        <span class="hljs-keyword">case</span> MessageBC:            &#123;                ModuleB* pFromWhere = <span class="hljs-keyword">dynamic_cast</span>&lt;ModuleB*&gt;(pFrom);                <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != pFromWhere)                &#123;                    m_pModC-&gt;vNotify(enMessage);                &#125;                <span class="hljs-keyword">else</span>                &#123;                    m_pModB-&gt;vNotify(enMessage);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetModuleA</span><span class="hljs-params">(ModuleBase* pModuleA)</span></span>&#123;m_pModA = pModuleA;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetModuleB</span><span class="hljs-params">(ModuleBase* pModuleB)</span></span>&#123;m_pModB = pModuleB;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetModuleC</span><span class="hljs-params">(ModuleBase* pModuleC)</span></span>&#123;m_pModC = pModuleC;&#125;<span class="hljs-keyword">private</span>:    ModuleBase* m_pModA;    ModuleBase* m_pModB;    ModuleBase* m_pModC;&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    MediatorBase* pMediator = <span class="hljs-keyword">new</span> ConcreteMediator();    <span class="hljs-comment">//为所有模块指定中介者</span>    ModuleBase* pModA = <span class="hljs-keyword">new</span> ModuleA(pMediator);    ModuleBase* pModB = <span class="hljs-keyword">new</span> ModuleB(pMediator);    ModuleBase* pModC = <span class="hljs-keyword">new</span> ModuleC(pMediator);    <span class="hljs-comment">//为中介者设定模块</span>    ConcreteMediator* pConcreteMediator = <span class="hljs-keyword">dynamic_cast</span>&lt;ConcreteMediator*&gt;(pMediator);    pConcreteMediator-&gt;SetModuleA(pModA);    pConcreteMediator-&gt;SetModuleB(pModB);    pConcreteMediator-&gt;SetModuleC(pModC);    <span class="hljs-comment">//各模块间开始互发消息</span>    pModA-&gt;SendMessage(MessageAC);    pModB-&gt;SendMessage(MessageBC);    pModC-&gt;SendMessage(MessageBC);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="">ModuleC get MessageAC from ModuleAModuleC get MessageBC form ModuleBModuleB get MessageBC form ModuleC</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;中介者模式：一种行为型设计模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;b</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="行为型" scheme="https://jeremyyvv.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>职责链模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:57:32.000Z</published>
    <updated>2021-03-21T12:46:51.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li><strong>职责链模式：一种行为型设计模式</strong></li><li><strong>应用场景：</strong><br />系统中会出现一些请求，而可以处理请求的处理者会有很多，如何将由适当的处理者处理请求，是职责链模式解决的问题。<br />职责链模式将所有处理者连成一条链，请求在链上传播，直至被处理完成。<br /><strong>举例：</strong><br />在公司的请假系统中，一般会分为n级审核人。一级审核人是组长，可以批准24小时以下请假申请；二级审核人是部门主管，可以批准48小时以下请假申请；而48小时以上的申请则需要由三级审核人，部门经理批准。<br />使用职责链模式将一二三级审核人连成一条链，申请由一级审核人开始审核，如果一级审核人不能批准则传给二级审核人、三级审核人。</li><li><strong>实现方式：</strong><br />创建一个审核者抽象类，类中只封装一个共同的处理请求纯虚函数。<br />一级审核人类中添加二级审核人作为成员变量，并在构造时初始化。处理请求函数中判断申请属性，如果不能处理，交给二级审核人审核。<br />二级审核人类中同上。</li></ul><hr /><h1 id="职责链模式的简单代码实现"><a class="markdownIt-Anchor" href="#职责链模式的简单代码实现"></a> 职责链模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//假期请求类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HolidayRequest</span>&#123;</span><span class="hljs-keyword">public</span>:HolidayRequest(<span class="hljs-keyword">int</span> iHour):m_iHour(iHour)&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetHour</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> m_iHour;&#125;<span class="hljs-keyword">private</span>: <span class="hljs-keyword">int</span> m_iHour;<span class="hljs-comment">//请求的假期时间</span>&#125;;<span class="hljs-comment">//审批者抽象类</span><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">Approver</span>&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">DealRequest</span><span class="hljs-params">(HolidayRequest*)</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">//一级审批者，可审批24小时以下假期申请</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstLevelApprover</span> :</span> <span class="hljs-keyword">public</span> Approver&#123;<span class="hljs-keyword">public</span>:FirstLevelApprover(Approver* pApprover):m_pApprover(pApprover)&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">DealRequest</span><span class="hljs-params">(HolidayRequest* pReq)</span></span>&#123;<span class="hljs-keyword">if</span>(pReq-&gt;GetHour() &lt; <span class="hljs-number">24</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"First Level Approved"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> m_pApprover-&gt;DealRequest(pReq);&#125;<span class="hljs-keyword">private</span>:Approver* m_pApprover;&#125;;<span class="hljs-comment">//二级审批者，可审批48小时以下假期申请</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondLevelApprover</span> :</span> <span class="hljs-keyword">public</span> Approver&#123;<span class="hljs-keyword">public</span>:SecondLevelApprover(Approver* pApprover):m_pApprover(pApprover)&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">DealRequest</span><span class="hljs-params">(HolidayRequest* pReq)</span></span>&#123;<span class="hljs-keyword">if</span>(pReq-&gt;GetHour() &lt; <span class="hljs-number">48</span>)&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Second Level Approved"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">return</span> m_pApprover-&gt;DealRequest(pReq);&#125;<span class="hljs-keyword">private</span>:Approver* m_pApprover;&#125;;<span class="hljs-comment">//一级审批者，审批48小时以上假期申请</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThirdLevelApprover</span> :</span> <span class="hljs-keyword">public</span> Approver&#123;<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">DealRequest</span><span class="hljs-params">(HolidayRequest* pReq)</span></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Third Level Approved"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;ThirdLevelApprover* pThird = <span class="hljs-keyword">new</span> ThirdLevelApprover();SecondLevelApprover* pSecond = <span class="hljs-keyword">new</span> SecondLevelApprover(pThird);FirstLevelApprover* pFirst = <span class="hljs-keyword">new</span> FirstLevelApprover(pSecond);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=====18-Hours Request====="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;HolidayRequest* pReq1 = <span class="hljs-keyword">new</span> HolidayRequest(<span class="hljs-number">18</span>);pFirst-&gt;DealRequest(pReq1);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=====36-Hours Request====="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;HolidayRequest* pReq2 = <span class="hljs-keyword">new</span> HolidayRequest(<span class="hljs-number">36</span>);pFirst-&gt;DealRequest(pReq2);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=====72-Hours Request====="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;HolidayRequest* pReq3 = <span class="hljs-keyword">new</span> HolidayRequest(<span class="hljs-number">72</span>);pFirst-&gt;DealRequest(pReq3);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="">=====18-Hours Request=====First Level Approved=====36-Hours Request=====Second Level Approved=====72-Hours Request=====Third Level Approved</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;职责链模式：一种行为型设计模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;b</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="行为型" scheme="https://jeremyyvv.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>模板方法模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:56:32.000Z</published>
    <updated>2021-03-21T12:46:54.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li><strong>模板方法模式：一种行为型设计模式</strong></li><li><strong>应用场景：</strong><br />模板方法是一种代码复用的基本技术,定义了一个操作中的<strong>算法骨架</strong>，而将一些步骤<strong>延迟</strong>到子类中。<br />在使用模板方法时，很重要的一点是模板方法应当指明哪些操作是可以被重写的，以及哪些是必须被重写的。<br />此设计模式比较简单，直接看代码吧。</li></ul><hr /><h1 id="模板方法模式的简单代码实现"><a class="markdownIt-Anchor" href="#模板方法模式的简单代码实现"></a> 模板方法模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//默认的模板方法类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultTemplate</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//固定的模板方法流程</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TemplateMethod</span><span class="hljs-params">()</span>    </span>&#123;        Step1();        Step2();        Step3();    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Default Step1"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step2</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Default Step2"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Default Step3"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//重写步骤1、3</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewTemplate</span>:</span><span class="hljs-keyword">public</span> DefaultTemplate&#123;<span class="hljs-keyword">private</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step1</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"New Step1"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Step3</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"New Step3"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    DefaultTemplate oDefault;    oDefault.TemplateMethod();    NewTemplate oNew;    oNew.TemplateMethod();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="">Default Step1Default Step2Default Step3New Step1Default Step2New Step3</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;模板方法模式：一种行为型设计模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="行为型" scheme="https://jeremyyvv.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:55:32.000Z</published>
    <updated>2021-03-21T12:46:58.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li><strong>命令模式：一种行为型设计模式</strong></li><li><strong>应用场景：</strong><br />在GOF的《设计模式:可复用面向对象软件的基础》一书中对命令模式是这样说的：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，将请求排队或记录请求日志，以及支持可撤销的操作。<br />这段话的意思我在刚刚了解这个设计模式时没有很懂，可以在看完全文后再回来看一遍。<br />这个设计模式的应用很多。<br />即将要开始被天天谈论的12306订票网站，每个用户发起订票请求后，该请求不会被立即执行，而是会进入消息队列。同一用户再次发起请求时如果前一请求尚在队列中排队，新的请求会被忽略，避免了恶意刷票，优化了服务器的性能。而何时将队列中的消息取出，统一处理，将由系统其他设置决定。这个队列就是请求的收集者。<br /><strong>举例：</strong><br />我还是以公司里的审批制度举例。<br />在部门每月末收集报销单时，一般会指定一个收集者，这个人负责收集部门内所有的报销单，收集完成后统一交给审批者进行审批。<br />而且，不同种类的报销单可能由不同的人审批，都由这个收集者分配。<br />这个收集者就是上述的队列，他可以对报销单的审批顺序进行排列，也可以对数目和人员进行记录，以及支持撤销报销的操作。</li><li><strong>实现方式：</strong><br />需要创建三个类，请求类，审批人类和收集者类<br />请求类中要通过成员变量指定审批人，审批人要提供审批接口，收集者类中要有容器用来容纳请求，并提供统一处理的方法。</li></ul><hr /><h1 id="命令模式的简单代码实现"><a class="markdownIt-Anchor" href="#命令模式的简单代码实现"></a> 命令模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//请求抽象类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span>&#123;</span><span class="hljs-keyword">public</span>:Request(<span class="hljs-keyword">int</span> iNo):m_iNo(iNo)&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GetID</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> m_iNo;&#125;<span class="hljs-keyword">protected</span>:<span class="hljs-keyword">int</span> m_iNo;<span class="hljs-comment">//请求ID</span>&#125;;<span class="hljs-comment">//审核人</span><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">Approver</span>&#123;</span><span class="hljs-keyword">public</span>:Approver(<span class="hljs-built_in">string</span> strName):m_strName(strName)&#123;&#125;<span class="hljs-comment">//审核请求，打印信息</span><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DealRequest</span><span class="hljs-params">(Request* pRequest)</span></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Request "</span> &lt;&lt; pRequest-&gt;GetID() &lt;&lt; <span class="hljs-string">" Approved by "</span> &lt;&lt; m_strName &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">private</span>:<span class="hljs-built_in">string</span> m_strName;<span class="hljs-comment">//审核人的名字</span>&#125;;<span class="hljs-comment">//假期请求</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HolidayRequest</span> :</span> <span class="hljs-keyword">public</span> Request&#123;<span class="hljs-keyword">public</span>:<span class="hljs-comment">//构造时指定请求ID和审核人</span>HolidayRequest(<span class="hljs-keyword">int</span> iNO, Approver* pApprover):Request(iNO), m_pApprover(pApprover)&#123;&#125;<span class="hljs-comment">//请求被处理</span><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Execute</span><span class="hljs-params">()</span></span>&#123;m_pApprover-&gt;DealRequest(<span class="hljs-keyword">this</span>);&#125;<span class="hljs-keyword">private</span>:Approver* m_pApprover;&#125;;<span class="hljs-comment">//汇总请求者</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Invoker</span>&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-comment">//收集请求</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddReq</span><span class="hljs-params">(Request* pReq)</span></span>&#123;m_vecReq.push_back(pReq);&#125;<span class="hljs-comment">//统一申请</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InvokeAllReq</span><span class="hljs-params">()</span></span>&#123;for_each(m_vecReq.<span class="hljs-built_in">begin</span>(), m_vecReq.<span class="hljs-built_in">end</span>(),Invoke);&#125;<span class="hljs-keyword">private</span>:<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Invoke</span><span class="hljs-params">(Request* pReq)</span></span>&#123;<span class="hljs-keyword">if</span>(pReq)&#123;pReq-&gt;Execute();&#125;&#125;<span class="hljs-built_in">vector</span>&lt;Request*&gt; m_vecReq;&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//假设有两个经理负责审批，分别叫Mark和Nancy</span>Approver* pManagerMark = <span class="hljs-keyword">new</span> Approver(<span class="hljs-string">"Mark"</span>);Approver* pManagerNancy = <span class="hljs-keyword">new</span> Approver(<span class="hljs-string">"Nancy"</span>);<span class="hljs-comment">//一个请求收集者</span>Invoker* pInvoker = <span class="hljs-keyword">new</span> Invoker();pInvoker-&gt;AddReq(<span class="hljs-keyword">new</span> HolidayRequest(<span class="hljs-number">1</span>, pManagerMark));pInvoker-&gt;AddReq(<span class="hljs-keyword">new</span> HolidayRequest(<span class="hljs-number">2</span>, pManagerMark));pInvoker-&gt;AddReq(<span class="hljs-keyword">new</span> HolidayRequest(<span class="hljs-number">3</span>, pManagerNancy));pInvoker-&gt;AddReq(<span class="hljs-keyword">new</span> HolidayRequest(<span class="hljs-number">4</span>, pManagerNancy));<span class="hljs-comment">//收集所有请求后统一送去审批</span>pInvoker-&gt;InvokeAllReq();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="">Request 1  Approved by MarkRequest 2  Approved by MarkRequest 3  Approved by NancyRequest 4  Approved by Nancy</code></pre><p><strong>嗯 ~ 现在可以回去再看一遍文章开头从GOF书中摘抄的描述了 ~</strong></p><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;命令模式：一种行为型设计模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;br</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="行为型" scheme="https://jeremyyvv.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>解释器模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:54:32.000Z</published>
    <updated>2021-03-21T12:47:01.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li><strong>解释器模式：一种行为型设计模式</strong></li></ul><p><strong>首先，我想先说明一下，解释器模式是我个人认为最复杂的设计模式，可能因为我目前对编程语言的解析原理不甚了解，对这个模式的理解也很片面。</strong></p><ul><li><p><strong>应用场景：</strong><br />解释器模式的应用场景是<strong>对语句进行解析</strong>。给定<strong>语法规则</strong>，先将语句形成<strong>语义树</strong>，然后通过解释器<strong>对语义树进行解释</strong>，输出结果。<br />常用场景如<strong>解析xml配置文件</strong>。</p></li><li><p><strong>举例：</strong><br />以解析**<code>a+b+c</code><strong>来举例，将<code>a</code>，<code>+</code>，<code>b</code>，<code>+</code>，<code>c</code>五个符号作为独立的</strong>对象<strong>来解析。<br />这五个符号根据</strong>解析方式不同<strong>可分为两类，<code>a b c</code>为一类，这类对象的解析结果就是这个对象</strong>本身的值**。而<code>+</code>的解析要取这个元素左右相邻的两个元素，进行<strong>相加</strong>，将和作为解析结果返回。<br />解释前<strong>先生成语义树</strong>，类似这样：</p></li></ul><pre class="highlight"><code class="">      +    /   \   +     c  /   \ a     b</code></pre><p>然后从<strong>根节点</strong>开始，依次对节点进行<strong>递归</strong>解析。<code>a b c</code>这类解释器使程序不会无限递归下去，称作<strong>终结符解释器</strong>（终结递归）。另一类需要递归向下解析的，称作<strong>非终结符解释器</strong>。</p><ul><li><strong>实现方式：</strong><br />解释器基类派生出<strong>终结符解释器</strong>和<strong>非终结符解释器</strong>，非终结符解释器根据解释功能派生出<strong>具体的解释器类</strong>（<strong><code>+</code><strong>调用左右两数相加，</strong><code>-</code><strong>调用左右两数相减）。<br />再有一个</strong>解析器</strong>，将语句生成语义树。</li></ul><hr /><h1 id="解释器模式的简单代码实现"><a class="markdownIt-Anchor" href="#解释器模式的简单代码实现"></a> 解释器模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;typeinfo&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//解释器抽象类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Expression</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//解析公式和数值，其中mapValue中的key是公式中的参数，value值是具体的值</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&amp; MapValue)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~Expression()&#123;&#125;;&#125;;<span class="hljs-comment">//变量解析器（终结符）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VarExpression</span> :</span> <span class="hljs-keyword">public</span> Expression&#123;    <span class="hljs-built_in">string</span> m_strkey;<span class="hljs-keyword">public</span>:    VarExpression(<span class="hljs-built_in">string</span> strkey):m_strkey(strkey)&#123;&#125;    <span class="hljs-comment">//从map中取出变量的值</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&amp; MapValue)</span>    </span>&#123;        <span class="hljs-keyword">return</span> MapValue[m_strkey];    &#125;&#125;;<span class="hljs-comment">//运算符解析器（非终结符）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SymbolExpression</span> :</span> <span class="hljs-keyword">public</span> Expression&#123;<span class="hljs-keyword">protected</span>:    Expression* m_pLeft;    Expression* m_pRight;<span class="hljs-keyword">public</span>:    SymbolExpression(Expression* pLeft, Expression* pRight):m_pLeft(pLeft), m_pRight(pRight)&#123;&#125;&#125;;<span class="hljs-comment">//加法解析器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddExpression</span> :</span> <span class="hljs-keyword">public</span> SymbolExpression&#123;<span class="hljs-keyword">public</span>:    AddExpression(Expression* pLeft, Expression* pRight):SymbolExpression(pLeft,pRight)&#123;&#125;    <span class="hljs-comment">//把左右两个变量相加</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&amp; MapValue)</span>    </span>&#123;        <span class="hljs-keyword">return</span> m_pLeft-&gt;interpreter(MapValue) + m_pRight -&gt;interpreter(MapValue);    &#125;&#125;;<span class="hljs-comment">//减法解析器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubExpression</span> :</span> <span class="hljs-keyword">public</span> SymbolExpression&#123;<span class="hljs-keyword">public</span>:    SubExpression(Expression* pLeft, Expression* pRight): SymbolExpression(pLeft,pRight)    &#123;    &#125;    <span class="hljs-comment">//把左右两个变量相减</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">interpreter</span><span class="hljs-params">(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&amp; MapValue)</span>    </span>&#123;        <span class="hljs-keyword">return</span> m_pLeft-&gt;interpreter(MapValue) - m_pRight -&gt;interpreter(MapValue);    &#125;&#125;;<span class="hljs-comment">//语义解析器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parse</span>&#123;</span><span class="hljs-keyword">private</span>:    Expression* m_pExpression;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">//构造函数传参，并解析表达式，构建语法树</span>    Parse(<span class="hljs-built_in">string</span> strExpStr)    &#123;        m_pExpression = <span class="hljs-literal">NULL</span>;        <span class="hljs-built_in">stack</span>&lt;Expression*&gt; stackExp;        Expression* pLeft  = <span class="hljs-literal">NULL</span>;        Expression* pRight = <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; strExpStr.length(); ++i)        &#123;            <span class="hljs-keyword">switch</span>(strExpStr[i])            &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:  <span class="hljs-comment">//加法</span>                <span class="hljs-comment">//1.先从栈中取出左操作数</span>                pLeft = stackExp.top();                stackExp.pop();                <span class="hljs-comment">//2.从表达式中取出+号后面的右操作数，并生成终结符解析对象</span>                pRight = <span class="hljs-keyword">new</span> VarExpression(strExpStr.substr(++i,<span class="hljs-number">1</span>));                <span class="hljs-comment">//3.将左右操作数相加，并把结果放入栈中</span>                stackExp.push(<span class="hljs-keyword">new</span> AddExpression(pLeft, pRight));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:                <span class="hljs-comment">//1.先从栈中取出左操作数</span>                pLeft = stackExp.top();                stackExp.pop();                <span class="hljs-comment">//2.从表达式中取出+号后面的右操作数，并生成终结符解析对象</span>                pRight = <span class="hljs-keyword">new</span> VarExpression(strExpStr.substr(++i,<span class="hljs-number">1</span>));                <span class="hljs-comment">//3.将左右操作数相减，并把结果放入栈中</span>                stackExp.push(<span class="hljs-keyword">new</span> SubExpression(pLeft, pRight));                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">default</span>:                <span class="hljs-comment">//如果是变量（终结符），</span>                <span class="hljs-comment">//则直接生成对应的变量解析器</span>                stackExp.push(<span class="hljs-keyword">new</span> VarExpression(strExpStr.substr(i,<span class="hljs-number">1</span>)));            &#125;        &#125;        <span class="hljs-comment">//栈中保存的就是最终语法树的根结点（本例为SuuExpression对象）</span>        <span class="hljs-keyword">if</span>(!stackExp.empty())        &#123;            m_pExpression = stackExp.top();            stackExp.pop();        &#125;    &#125;    <span class="hljs-comment">//开始运算</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&amp; MapValue)</span>    </span>&#123;        <span class="hljs-keyword">return</span> (!m_pExpression) ? <span class="hljs-number">0</span> : m_pExpression-&gt;interpreter(MapValue);    &#125;&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">string</span> strExpression = <span class="hljs-string">"a-b+c"</span>;    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; MapValue;    MapValue[<span class="hljs-string">"a"</span>] = <span class="hljs-number">50</span>;    MapValue[<span class="hljs-string">"b"</span>] = <span class="hljs-number">40</span>;    MapValue[<span class="hljs-string">"c"</span>] = <span class="hljs-number">30</span>;    <span class="hljs-function">Parse <span class="hljs-title">ParseTree</span><span class="hljs-params">(strExpression)</span></span>; <span class="hljs-comment">//生成语义树</span>    <span class="hljs-built_in">cout</span> &lt;&lt; strExpression &lt;&lt; <span class="hljs-string">" = "</span> &lt;&lt; ParseTree.Calculate(MapValue) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="">a-b+c = 40</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解释器模式：一种行为型设计模式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;首先，我想先说明一下，</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="行为型" scheme="https://jeremyyvv.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:52:32.000Z</published>
    <updated>2021-03-21T12:50:49.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li><strong>观察者模式：一种行为型设计模式</strong></li><li><strong>应用场景：</strong><br />观察者模式定义了对象间<strong>一对多</strong>的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种交互也称为发布-订阅(publish-subscribe)。<br />观察者模式在设计模式中的地位非常高，在各大框架中的应用随处可见。<br />Qt框架中的信号槽机制就是观察者模式的典型应用：通过用户的点击，触发与按键点击所绑定的槽函数。</li><li><strong>举例：</strong><br />假设公司中的Boss要发邮件通知所有下属员工，那么首先需要在Boss端保存一个所有下属的邮箱列表，<br />这样Boss要统一通知所有下属员工时，直接向列表中的邮箱逐个发送即可。</li><li><strong>实现方式：</strong><br />Boss类就是被观察者类，类中要有一个用以保存所有下属邮箱的容器，还要有一个通知容器中所有对象的方法。<br />每名下属员工为一个观察者对象，有一个被通知的方法。</li></ul><hr /><h1 id="观察者模式的简单代码实现"><a class="markdownIt-Anchor" href="#观察者模式的简单代码实现"></a> 观察者模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//观察者抽象类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReceiveMail</span><span class="hljs-params">(<span class="hljs-built_in">string</span> strMessage)</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">//被观察者抽象类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddObserver</span><span class="hljs-params">(Observer* pObserver)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DeleteObserver</span><span class="hljs-params">(Observer* pObserver)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendMail</span><span class="hljs-params">(<span class="hljs-built_in">string</span> strMessage)</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">//被观察者实现类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boss</span>:</span><span class="hljs-keyword">public</span> Subject&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">//添加观察者</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddObserver</span><span class="hljs-params">(Observer *pObserver)</span>    </span>&#123;        setObs.insert(pObserver);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DeleteObserver</span><span class="hljs-params">(Observer *pObserver)</span>    </span>&#123;        setObs.erase(pObserver);    &#125;    <span class="hljs-comment">//通知所有观察者</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendMail</span><span class="hljs-params">(<span class="hljs-built_in">string</span> strMessage)</span>    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter = setObs.<span class="hljs-built_in">begin</span>(); iter != setObs.<span class="hljs-built_in">end</span>(); ++iter)        &#123;            (*iter)-&gt;ReceiveMail(strMessage);        &#125;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-comment">//存放观察者的容器</span>    <span class="hljs-built_in">set</span>&lt;Observer*&gt; setObs;&#125;;<span class="hljs-comment">//观察者实现类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Staff</span>:</span><span class="hljs-keyword">public</span> Observer&#123;<span class="hljs-keyword">public</span>:    Staff(<span class="hljs-built_in">string</span> strName):m_strName(strName)&#123;&#125;    <span class="hljs-comment">//收到通知，取邮件并显示</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ReceiveMail</span><span class="hljs-params">(<span class="hljs-built_in">string</span> strMessage)</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Staff "</span> &lt;&lt; m_strName &lt;&lt; <span class="hljs-string">" Receive Mail:"</span> &lt;&lt; strMessage &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> m_strName;&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Subject* pBoss = <span class="hljs-keyword">new</span> Boss();    Observer* pStaffA = <span class="hljs-keyword">new</span> Staff(<span class="hljs-string">"Mark"</span>);    pBoss-&gt;AddObserver(pStaffA);    Observer* pStaffB = <span class="hljs-keyword">new</span> Staff(<span class="hljs-string">"Jeremy"</span>);    pBoss-&gt;AddObserver(pStaffB);    pBoss-&gt;SendMail(<span class="hljs-string">"test"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="">Staff Mark Receive Mail:testStaff Jeremy Receive Mail:test</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;观察者模式：一种行为型设计模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;b</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="行为型" scheme="https://jeremyyvv.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>访问者模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:51:32.000Z</published>
    <updated>2021-03-21T12:47:09.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li><strong>访问者模式：一种行为型设计模式</strong></li><li><strong>应用场景：</strong><br />一个对象由很多部分组成，对这个对象的操作会对各部分依次操作。而在不同情景下，对各部分操作也不同。<br />为了新增操作时无需了解对象内部结构，且具备可扩展性，将操作抽离为访问者类，类中实现对各部分具体的操作方法。<br />然后在对象中提供一个接口用以访问者访问，在该接口总，对象会调用访问者中对应各部分的操作方法，操作对象中的各部分。</li><li><strong>举例：</strong><br />一台电脑中有很多组件，CPU、GPU、硬盘。维修人员对电脑进行整体维修时，需要对各部件依次进行维修，而且每部件具体的维修方式不同。不同的维修人员对相同的部件维修方式可能也不同。<br />维修人员就是访问者。访问者类中实现了针对不同部件的维修方式。<br />电脑就是被访问者。被访问者提供访问接口，使用访问者类中实现的不同部件维修方式，对内部部件进行访问。</li></ul><hr /><h1 id="访问者模式的简单代码实现"><a class="markdownIt-Anchor" href="#访问者模式的简单代码实现"></a> 访问者模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span>;</span><span class="hljs-comment">//组成Computer的各组件基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Element</span>&#123;</span><span class="hljs-keyword">public</span>:    Element(<span class="hljs-built_in">string</span> strName):m_strName(strName)&#123;&#125;    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-keyword">return</span> m_strName;    &#125;    <span class="hljs-comment">//组件接受访问者访问的接口</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AcceptVisitor</span><span class="hljs-params">(Visitor* pVisitor)</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span>:    <span class="hljs-comment">//组件的标识名称</span>    <span class="hljs-built_in">string</span> m_strName;&#125;;<span class="hljs-comment">//访问者基类，针对不同组件，提供不同的访问接口</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Visitor</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VisitCPU</span><span class="hljs-params">(Element* pEle)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VisitGPU</span><span class="hljs-params">(Element* pEle)</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">VisitDISK</span><span class="hljs-params">(Element* pEle)</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">//Computer类，由各组件组成，访问者访问Computer时将依次访问各组件</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span>&#123;</span><span class="hljs-keyword">public</span>:    ~Computer()    &#123;        <span class="hljs-keyword">for</span>(Element* pElement: m_listEle)        &#123;            <span class="hljs-keyword">delete</span> pElement;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddElement</span><span class="hljs-params">(Element* pEle)</span>    </span>&#123;        m_listEle.push_back(pEle);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DelElement</span><span class="hljs-params">(Element* pEle)</span>    </span>&#123;        m_listEle.<span class="hljs-built_in">remove</span>(pEle);    &#125;    <span class="hljs-comment">//访问者访问Computer时将依次访问各组件</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AcceptVisitor</span><span class="hljs-params">(Visitor* pVisitor)</span>    </span>&#123;        <span class="hljs-keyword">for</span>(Element* pElement: m_listEle)        &#123;            pElement-&gt;AcceptVisitor(pVisitor);        &#125;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">list</span>&lt;Element*&gt; m_listEle;&#125;;<span class="hljs-comment">//访问者实现类，实现各自的访问方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisitorA</span> :</span> <span class="hljs-keyword">public</span> Visitor&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">VisitCPU</span><span class="hljs-params">(Element* pEle)</span>    </span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Visitor A record CPU's name:%s\n"</span>, pEle-&gt;GetName().c_str());    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">VisitGPU</span><span class="hljs-params">(Element* pEle)</span>    </span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Visitor A do nothing to GPU:%s\n"</span>, pEle-&gt;GetName().c_str());    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">VisitDISK</span><span class="hljs-params">(Element* pEle)</span>    </span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Visitor A change DISK:%s\n"</span>, pEle-&gt;GetName().c_str());    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VisitorB</span> :</span> <span class="hljs-keyword">public</span> Visitor&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">VisitCPU</span><span class="hljs-params">(Element* pEle)</span>    </span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Visitor B do nothing to CPU:%s\n"</span>, pEle-&gt;GetName().c_str());    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">VisitGPU</span><span class="hljs-params">(Element* pEle)</span>    </span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Visitor B record GPU's name:%s\n"</span>, pEle-&gt;GetName().c_str());    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">VisitDISK</span><span class="hljs-params">(Element* pEle)</span>    </span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Visitor B do nothing to DISK:%s\n"</span>, pEle-&gt;GetName().c_str());    &#125;&#125;;<span class="hljs-comment">//组件的实现类，调用访问者相应的访问方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CPU</span>:</span><span class="hljs-keyword">public</span> Element&#123;<span class="hljs-keyword">public</span>:    CPU(<span class="hljs-built_in">string</span> strName):Element(strName)&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AcceptVisitor</span><span class="hljs-params">(Visitor* pVisitor)</span>    </span>&#123;        pVisitor-&gt;VisitCPU(<span class="hljs-keyword">this</span>);    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GPU</span>:</span><span class="hljs-keyword">public</span> Element&#123;<span class="hljs-keyword">public</span>:    GPU(<span class="hljs-built_in">string</span> strName):Element(strName)&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AcceptVisitor</span><span class="hljs-params">(Visitor* pVisitor)</span>    </span>&#123;        pVisitor-&gt;VisitGPU(<span class="hljs-keyword">this</span>);    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Disk</span>:</span><span class="hljs-keyword">public</span> Element&#123;<span class="hljs-keyword">public</span>:    Disk(<span class="hljs-built_in">string</span> strName):Element(strName)&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AcceptVisitor</span><span class="hljs-params">(Visitor* pVisitor)</span>    </span>&#123;        pVisitor-&gt;VisitDISK(<span class="hljs-keyword">this</span>);    &#125;&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Computer oComputer;    oComputer.AddElement(<span class="hljs-keyword">new</span> CPU(<span class="hljs-string">"i9-10980XE"</span>));    oComputer.AddElement(<span class="hljs-keyword">new</span> GPU(<span class="hljs-string">"Titan RTX"</span>));    oComputer.AddElement(<span class="hljs-keyword">new</span> Disk(<span class="hljs-string">"HOF PRO M.2"</span>));    VisitorA oVisitorA;    VisitorB oVisitorB;    oComputer.AcceptVisitor(&amp;oVisitorA);    oComputer.AcceptVisitor(&amp;oVisitorB);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="">Visitor A record CPU's name:i9-10980XEVisitor A do nothing to GPU:Titan RTXVisitor A change DISK:HOF PRO M.2Visitor B do nothing to CPU:i9-10980XEVisitor B record GPU's name:Titan RTXVisitor B do nothing to DISK:HOF PRO M.2</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;访问者模式：一种行为型设计模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;b</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="行为型" scheme="https://jeremyyvv.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:50:32.000Z</published>
    <updated>2021-03-21T12:47:13.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li><strong>迭代器模式：一种行为型设计模式</strong></li><li><strong>应用场景：</strong><br />刚学习C++STL容器的时候，自然也学习了迭代器。当时很不懂为什么指针可以解决的问题，要封成一个表现和指针很类似的类，还起了个新名词叫迭代器。<br />后来对多种数据结构的应用渐渐有了了解之后，大致知道了迭代器的优点。<br />再后来学习到了迭代器模式，才懂得<strong>迭代器是一种思想</strong>，可以<strong>隐藏</strong>容器的内部<strong>实现细节</strong>，向使用者提供<strong>简单</strong>的方式进行<strong>容器内元素的迭代访问</strong>。</li><li><strong>举例：</strong><br />数组和链表，一个是<strong>连续</strong>内存，一个是<strong>非连续</strong>内存。在这两种数据结构中，对某个元素<strong>下一个元素的访问方式是不同的</strong>，数组可以通过将前一元素<strong>下标+1</strong>访问下一元素，而链表需要通过当前节点的<strong>Next指针</strong>获取下一元素的地址，再进行元素访问。<br />这样对用户来说体验是<strong>很不友好</strong>的。用户需要记住<strong>每种</strong>容器的迭代访问方式，大大降低了<strong>使用效率</strong>。<br />所以如果每种容器都能提供给用户<strong>统一</strong>的访问方式，就可以解决这个状况了，于是<strong>迭代器模式</strong>登场了。</li><li><strong>实现方式：</strong><br />每种容器在实现的同时，提供一个<strong>相对应的迭代器类</strong>。迭代器类中保存一个<strong>指针</strong>，指向链表中的某个节点，通过<strong>重载<code>++</code>运算符，封装指针移向下一个节点的过程</strong>。<br />这样用户在想要访问容器内元素的时候，<strong>无需关注容器内部实现细节</strong>，只需通过迭代器对象，调用<code>++</code>即可访问下一个元素了。</li></ul><hr /><h1 id="迭代器模式的简单代码实现"><a class="markdownIt-Anchor" href="#迭代器模式的简单代码实现"></a> 迭代器模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//自定义的节点</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span>    <span class="hljs-keyword">int</span> iData;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">pNext</span>;</span>&#125;NODE;<span class="hljs-comment">//自定义的某种容器</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span>&#123;</span><span class="hljs-keyword">public</span>:    MyList():m_pHead(<span class="hljs-literal">NULL</span>), m_pTail(<span class="hljs-literal">NULL</span>)&#123;&#125;    <span class="hljs-comment">//添加元素</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> iNewData)</span>    </span>&#123;        NODE* pNewNode = <span class="hljs-keyword">new</span> Node();        pNewNode-&gt;iData = iNewData;        pNewNode-&gt;pNext = <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == m_pHead)        &#123;            m_pHead = pNewNode;            m_pTail = m_pHead;        &#125;        <span class="hljs-keyword">else</span>        &#123;            m_pTail-&gt;pNext = pNewNode;            m_pTail = m_pTail-&gt;pNext;        &#125;    &#125;    <span class="hljs-comment">//获取头指针位置</span>    <span class="hljs-function">Node* <span class="hljs-title">Begin</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-keyword">return</span> m_pHead;    &#125;    <span class="hljs-comment">//获取尾指针位置</span>    <span class="hljs-function">Node* <span class="hljs-title">End</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-keyword">return</span> m_pTail-&gt;pNext;    &#125;<span class="hljs-keyword">private</span>:    NODE* m_pHead;    NODE* m_pTail;&#125;;<span class="hljs-comment">//自定义容器对应的迭代器类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListIterator</span>&#123;</span><span class="hljs-keyword">public</span>:    MyListIterator(Node* pNode = <span class="hljs-literal">NULL</span>)    &#123;        m_pCurrentNode = pNode;    &#125;    Node* <span class="hljs-keyword">operator</span>=(Node* pNode)    &#123;        m_pCurrentNode = pNode;        <span class="hljs-keyword">return</span> m_pCurrentNode;    &#125;    <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>*()    &#123;        <span class="hljs-keyword">return</span> m_pCurrentNode-&gt;iData;    &#125;    MyListIterator&amp; <span class="hljs-keyword">operator</span>++()    &#123;        m_pCurrentNode = m_pCurrentNode-&gt;pNext;        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    &#125;<span class="hljs-keyword">private</span>:    NODE* m_pCurrentNode;&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//先向自定义容器中填充数据</span>    MyList oList;    oList.Add(<span class="hljs-number">1</span>);    oList.Add(<span class="hljs-number">2</span>);    <span class="hljs-comment">//访问并输出</span>    MyListIterator oIterator = oList.Begin();    <span class="hljs-built_in">cout</span> &lt;&lt; *oIterator &lt;&lt; <span class="hljs-built_in">endl</span>;    ++oIterator;    <span class="hljs-built_in">cout</span> &lt;&lt; *oIterator &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="">12</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;迭代器模式：一种行为型设计模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;b</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="行为型" scheme="https://jeremyyvv.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:49:00.000Z</published>
    <updated>2021-03-21T12:47:17.519Z</updated>
    
    <content type="html"><![CDATA[<h3 id="策略模式一种行为型设计模式"><a class="markdownIt-Anchor" href="#策略模式一种行为型设计模式"></a> 策略模式：一种行为型设计模式</h3><ul><li><strong>应用场景：</strong><br />在GOF的《设计模式:可复用面向对象软件的基础》中是这样定义的：将一系列的算法一个个封装起来，并且使它们可相互替换。策略模式使得算法可独立于使用它的客户而变化。<br />对于同一流程中不同的需求，对数据的处理算法可能会变更，所以将处理数据的算法单独抽离出去，形成一系列算法类，可以相互替换。</li><li><strong>举例：</strong><br />《大话设计模式》中举了一个很好的例子。<br />商场经常会推出不同的优惠活动，对于结账流程来说，不同的优惠活动会使用不同的算法处理账单总额。<br />所以抽离出一个算法的基类，提供统一的用于计算折后价的接口，然后所有的算法都在派生类中实现各自的方法。<br />切换商场类中的算法指针所指向的算法类，即可切换调用的算法。</li><li><strong>实现方式：</strong><br />所有算法类派生自同一基类，实现统一的计算接口。<br />商场类中使用成员指针指向具体的算法类，结账时通过该指针调用算法。</li></ul><hr /><h1 id="策略模式的简单代码实现"><a class="markdownIt-Anchor" href="#策略模式的简单代码实现"></a> 策略模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//策略基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fTotal)</span> </span>= <span class="hljs-number">0</span>;&#125;;<span class="hljs-comment">//策略A，打8折</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyA</span>:</span><span class="hljs-keyword">public</span> Strategy&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fTotal)</span>    </span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"优惠活动，全部8折\n"</span>);        <span class="hljs-keyword">return</span> fTotal * <span class="hljs-number">0.8</span>;    &#125;&#125;;<span class="hljs-comment">//策略B，打7折</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyB</span>:</span><span class="hljs-keyword">public</span> Strategy&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fTotal)</span>    </span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"优惠活动，全部7折\n"</span>);        <span class="hljs-keyword">return</span> fTotal * <span class="hljs-number">0.7</span>;    &#125;&#125;;<span class="hljs-comment">//策略C，满300减100</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyC</span>:</span><span class="hljs-keyword">public</span> Strategy&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">float</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fTotal)</span>    </span>&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"优惠活动，满300减100\n"</span>);        <span class="hljs-keyword">float</span> fFinal = fTotal - <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(fTotal/<span class="hljs-number">300</span>) * <span class="hljs-number">100</span>;        <span class="hljs-keyword">return</span> fFinal;    &#125;&#125;;<span class="hljs-comment">//商场类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shop</span>&#123;</span><span class="hljs-keyword">public</span>:    Shop(Strategy* pStrategy = <span class="hljs-literal">NULL</span>):m_pStrategy(pStrategy)&#123;&#125;    ~Shop()    &#123;        <span class="hljs-keyword">if</span>(m_pStrategy)        &#123;            <span class="hljs-keyword">delete</span> m_pStrategy;            m_pStrategy = <span class="hljs-literal">NULL</span>;        &#125;    &#125;    <span class="hljs-comment">//设置商场策略</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetStrategy</span><span class="hljs-params">(Strategy* pStrategy)</span>    </span>&#123;        <span class="hljs-keyword">if</span>(m_pStrategy)        &#123;            <span class="hljs-keyword">delete</span> m_pStrategy;        &#125;        m_pStrategy = pStrategy;    &#125;    <span class="hljs-comment">//调用策略类的计算方法计算折后价</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CalculatePay</span><span class="hljs-params">(<span class="hljs-keyword">float</span> fTotal)</span>    </span>&#123;        <span class="hljs-keyword">if</span>(m_pStrategy)        &#123;            <span class="hljs-keyword">float</span> fFinal = m_pStrategy-&gt;Calculate(fTotal);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"原价:%.2f元, 折后:%.2f元\n"</span>, fTotal, fFinal);        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"无活动，总价:%.2f元\n"</span>, fTotal);        &#125;    &#125;<span class="hljs-keyword">private</span>:    Strategy* m_pStrategy;&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Shop oShop;    oShop.CalculatePay(<span class="hljs-number">400</span>);    oShop.SetStrategy(<span class="hljs-keyword">new</span> StrategyA());    oShop.CalculatePay(<span class="hljs-number">400</span>);    oShop.SetStrategy(<span class="hljs-keyword">new</span> StrategyB());    oShop.CalculatePay(<span class="hljs-number">400</span>);    oShop.SetStrategy(<span class="hljs-keyword">new</span> StrategyC());    oShop.CalculatePay(<span class="hljs-number">400</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="">无活动，总价:400.00元优惠活动，全部8折原价:400.00元, 折后:320.00元优惠活动，全部7折原价:400.00元, 折后:280.00元优惠活动，满300减100原价:400.00元, 折后:300.00元</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;策略模式一种行为型设计模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#策略模式一种行为型设计模式&quot;&gt;&lt;/a&gt; 策略模式：一种行为型设计模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;br /&gt;
在GO</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="行为型" scheme="https://jeremyyvv.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>备忘录模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:48:00.000Z</published>
    <updated>2021-03-21T12:47:20.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li><p><strong>备忘录模式：一种行为型设计模式</strong></p></li><li><p><strong>应用场景：</strong><br />备忘录模式是对原型模式的<strong>进一步</strong>思考，因为有些时候我们并不需要一个完整对象的拷贝，只需要拷贝对象的一部分数据作为备份即可。<br />最典型的例子是虚拟机VWware，它的快照功能用以保存系统当前状态以便日后恢复。但如果是使用原型模式实现这个功能，每次快照时都需要生成一个完整的系统文件，是<strong>非常占用空间</strong>的。于是便进一步思考， 备份的时候<strong>只备份系统中必要的状态信息</strong>，日后通过这份不完整的备份信息，也可以使系统恢复到快照中的状态，就可以避免无用的备份信息占用空间。<br />每次的快照就是<strong>备忘记录</strong>，再指定一个<strong>管理者来管理所有的快照</strong>，这就是<strong>备忘录模式</strong>。</p></li><li><p><strong>举例：</strong><br />假设有一个游戏角色，它有很多属性，如姓名、血量、攻击力等，在存档备份的时候并不需要生成一个完整的角色对象作为拷贝，只需要存储血量、攻击力即可，因为姓名不会随着游戏进度更改。</p></li><li><p><strong>实现方式：</strong><br />为角色类创建一个对应的备份类，该类中只将必要的备份信息作为成员变量<br />在角色类中实现一个方法，该方法创建一个备份类对象作为返回值。<br />然后再创建一个管理者类，使用容器存放备份类对象。</p></li></ul><h1 id="备忘录模式的简单代码实现"><a class="markdownIt-Anchor" href="#备忘录模式的简单代码实现"></a> 备忘录模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//单条备忘的记录</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span>&#123;</span><span class="hljs-keyword">public</span>:    Memento(<span class="hljs-keyword">uint32_t</span> uiLevel, <span class="hljs-keyword">uint32_t</span> uiHp, <span class="hljs-keyword">uint32_t</span> uiAttack)        :m_uiLevel(uiLevel),m_uiHp(uiHp),m_uiAttack(uiAttack)    &#123;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">uint32_t</span> m_uiLevel;    <span class="hljs-keyword">uint32_t</span> m_uiHp;    <span class="hljs-keyword">uint32_t</span> m_uiAttack;&#125;;<span class="hljs-comment">//需要保存的数据类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameRole</span>&#123;</span><span class="hljs-keyword">public</span>:    GameRole(<span class="hljs-built_in">string</span> strName)        :m_strName(strName)        ,m_uiLevel(<span class="hljs-number">1</span>)        ,m_uiHp(<span class="hljs-number">100</span>)        ,m_uiAttack(<span class="hljs-number">10</span>)    &#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Name:"</span> &lt;&lt; m_strName &lt;&lt; <span class="hljs-string">" Level:"</span> &lt;&lt; m_uiLevel &lt;&lt; <span class="hljs-string">" HP:"</span> &lt;&lt; m_uiHp &lt;&lt; <span class="hljs-string">" ATK:"</span> &lt;&lt; m_uiAttack &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function">Memento* <span class="hljs-title">Save</span><span class="hljs-params">()</span>    </span>&#123;        Memento* pSaveInfo = <span class="hljs-keyword">new</span> Memento(m_uiLevel, m_uiHp, m_uiAttack);        <span class="hljs-keyword">return</span> pSaveInfo;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Load</span><span class="hljs-params">(Memento* pMem)</span>    </span>&#123;        m_uiLevel = pMem-&gt;m_uiLevel;        m_uiHp = pMem-&gt;m_uiHp;        m_uiAttack = pMem-&gt;m_uiAttack;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Loaded"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> m_strName;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">uint32_t</span> m_uiLevel;    <span class="hljs-keyword">uint32_t</span> m_uiHp;    <span class="hljs-keyword">uint32_t</span> m_uiAttack;&#125;;<span class="hljs-comment">//备忘管理者</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Recorder</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Record</span><span class="hljs-params">(Memento* pMem)</span>    </span>&#123;        vecMemento.push_back(pMem);        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Saved"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-function">Memento* <span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> uiIndex)</span>    </span>&#123;        <span class="hljs-keyword">return</span> vecMemento[uiIndex];    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">vector</span>&lt;Memento*&gt; vecMemento;&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Recorder oRecorder;    <span class="hljs-function">GameRole <span class="hljs-title">oPlayer</span><span class="hljs-params">(<span class="hljs-string">"Mark"</span>)</span></span>;    oPlayer.Show();    oRecorder.Record(oPlayer.Save());    oPlayer.m_uiLevel = <span class="hljs-number">100</span>;    oPlayer.m_uiHp = <span class="hljs-number">1000</span>;    oPlayer.m_uiAttack = <span class="hljs-number">100</span>;    oPlayer.Show();    oPlayer.Load(oRecorder.Get(<span class="hljs-number">0</span>));    oPlayer.Show();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="shell">Name:Mark Level:1 HP:100 ATK:10SavedName:Mark Level:100 HP:1000 ATK:100LoadedName:Mark Level:1 HP:100 ATK:10</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;备忘录模式：一种行为型设计模式&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用场</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="行为型" scheme="https://jeremyyvv.github.io/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:47:00.000Z</published>
    <updated>2021-03-21T12:47:27.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li><strong>组合模式：一种结构型设计模式</strong></li><li><strong>应用场景：</strong><br />对象需要组合成树形结构以表示“部分-整体”的层次结构时。<br /><strong>举例：</strong><br />一家公司的OA系统（Office Automation, 自动化办公），公司部门为多级结构，分为一级、二级、三级部门，为表现这种系统的层次结构，可以考虑组合模式</li><li><strong>实现方式：</strong><br /><strong>首先</strong>，创建所有部门的共有基类，封装共用的方法。<br /><strong>然后</strong>，在基类中添加用于存放子部门的容器，对子部门执行的操作，通过迭代该容器来完成。并封装向容器中添加和删除子部门的方法。<br /><strong>最后</strong>，各级部门类继承自该基类，并增添各自的方法。<br /><strong>备注</strong>：内存管理可以在基类中实现。</li><li><strong>优点：</strong><br />可以清楚地定义分层次的复杂对象，并可以不断组合。</li><li><strong>缺点：</strong><br />1.将子部门容器与添加/删除方法放在基类中，会使所有部门都有该容器与方法。但有些没有子部门的部门，在逻辑上不应该有这些。<br />2.如果不将子部门容器与添加/删除方法放在基类中，则有子部门但是功能不同的各部门需要在继承时重复实现容器与方法，代码重复会很多。<br />3.对哦，如果把有子部门的部门抽象出一个继承自基类的抽象类，可能会解决这个问题吧？稍后我会试一试</li></ul><hr /><h1 id="组合模式的简单代码实现"><a class="markdownIt-Anchor" href="#组合模式的简单代码实现"></a> 组合模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//部门抽象类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Department</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">//构造，传入部门名称作为部门标记</span>    Department(<span class="hljs-built_in">string</span> strName):m_strName(strName)&#123;&#125;    <span class="hljs-comment">//内存管理，析构时析构所有下属部门</span>    <span class="hljs-keyword">virtual</span> ~Department()    &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; m_strName &lt;&lt; <span class="hljs-string">"部门解散"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-comment">//下属部门析构</span>        <span class="hljs-built_in">list</span>&lt;Department*&gt;::iterator Iter = m_listDep.<span class="hljs-built_in">begin</span>();        <span class="hljs-keyword">for</span>(; Iter != m_listDep.<span class="hljs-built_in">end</span>(); ++Iter)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != (*Iter))            &#123;                <span class="hljs-keyword">delete</span> (*Iter);                (*Iter) = <span class="hljs-literal">NULL</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">//获取部门名称的方法</span>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">GetName</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-keyword">return</span> m_strName;    &#125;    <span class="hljs-comment">//展示所有下属部门名称</span>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowSubDep</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; m_strName &lt;&lt; <span class="hljs-string">"部门下属部门："</span>;        <span class="hljs-built_in">list</span>&lt;Department*&gt;::iterator Iter = m_listDep.<span class="hljs-built_in">begin</span>();        <span class="hljs-keyword">for</span>(; Iter != m_listDep.<span class="hljs-built_in">end</span>(); ++Iter)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; (*Iter)-&gt;GetName();        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//添加下属部门并打印信息</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AddDepartment</span><span class="hljs-params">(Department* pDep)</span>    </span>&#123;        m_listDep.push_back(pDep);        <span class="hljs-built_in">cout</span> &lt;&lt; m_strName &lt;&lt; <span class="hljs-string">"部门增加了下属的"</span> &lt;&lt; pDep-&gt;GetName() &lt;&lt; <span class="hljs-string">"部门"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//删除下属部门并打印信息</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DelDepartment</span><span class="hljs-params">(Department* pDep)</span>    </span>&#123;        <span class="hljs-built_in">list</span>&lt;Department*&gt;::iterator Iter = m_listDep.<span class="hljs-built_in">begin</span>();        <span class="hljs-keyword">for</span>(; Iter != m_listDep.<span class="hljs-built_in">end</span>(); ++Iter)        &#123;            <span class="hljs-keyword">if</span>(pDep == (*Iter))            &#123;                <span class="hljs-built_in">cout</span> &lt;&lt; m_strName &lt;&lt; <span class="hljs-string">"部门删除了下属的"</span> &lt;&lt; pDep-&gt;GetName() &lt;&lt; <span class="hljs-string">"部门"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;                <span class="hljs-keyword">delete</span> (*Iter);                m_listDep.erase(Iter);                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-built_in">string</span> m_strName;<span class="hljs-comment">//部门名称</span>    <span class="hljs-built_in">list</span>&lt;Department*&gt; m_listDep;<span class="hljs-comment">//存放下属部门的列表，用列表为了方便增删</span>&#125;;<span class="hljs-comment">//一级部门</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstLevelDepartment</span>:</span><span class="hljs-keyword">public</span> Department&#123;<span class="hljs-keyword">public</span>:    FirstLevelDepartment(<span class="hljs-built_in">string</span> strName):Department(strName)&#123;&#125;    <span class="hljs-keyword">virtual</span> ~FirstLevelDepartment()&#123;&#125;&#125;;<span class="hljs-comment">//二级部门</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondLevelDepartment</span>:</span><span class="hljs-keyword">public</span> Department&#123;<span class="hljs-keyword">public</span>:    SecondLevelDepartment(<span class="hljs-built_in">string</span> strName):Department(strName)&#123;&#125;    <span class="hljs-keyword">virtual</span> ~SecondLevelDepartment()&#123;&#125;&#125;;<span class="hljs-comment">//三级部门</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThirdLevelDepartment</span>:</span><span class="hljs-keyword">public</span> Department&#123;<span class="hljs-keyword">public</span>:    ThirdLevelDepartment(<span class="hljs-built_in">string</span> strName):Department(strName)&#123;&#125;    <span class="hljs-keyword">virtual</span> ~ThirdLevelDepartment()&#123;&#125;&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;composite.hpp&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//1级部门A1</span>    Department* pFstLvA = <span class="hljs-keyword">new</span> FirstLevelDepartment(<span class="hljs-string">"A1"</span>);    <span class="hljs-comment">//2级部门B2、C2、D2</span>    Department* pSndLvB = <span class="hljs-keyword">new</span> SecondLevelDepartment(<span class="hljs-string">"B2"</span>);    Department* pSndLvC = <span class="hljs-keyword">new</span> SecondLevelDepartment(<span class="hljs-string">"C2"</span>);    Department* pSndLvD = <span class="hljs-keyword">new</span> SecondLevelDepartment(<span class="hljs-string">"D2"</span>);    <span class="hljs-comment">//3级部门E3、F3、G3、H3</span>    Department* PTrdLvE = <span class="hljs-keyword">new</span> ThirdLevelDepartment(<span class="hljs-string">"E3"</span>);    Department* PTrdLvF = <span class="hljs-keyword">new</span> ThirdLevelDepartment(<span class="hljs-string">"F3"</span>);    Department* PTrdLvG = <span class="hljs-keyword">new</span> ThirdLevelDepartment(<span class="hljs-string">"G3"</span>);    Department* PTrdLvH = <span class="hljs-keyword">new</span> ThirdLevelDepartment(<span class="hljs-string">"H3"</span>);    <span class="hljs-comment">//组建树形结构</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=======组建部门结构======="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    pFstLvA-&gt;AddDepartment(pSndLvB);    pFstLvA-&gt;AddDepartment(pSndLvC);    pFstLvA-&gt;AddDepartment(pSndLvD);    pSndLvB-&gt;AddDepartment(PTrdLvE);    pSndLvB-&gt;AddDepartment(PTrdLvF);    pSndLvC-&gt;AddDepartment(PTrdLvG);    pSndLvD-&gt;AddDepartment(PTrdLvH);    <span class="hljs-comment">//展示一级部门A所有子部门</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"========展示子部门========"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    pFstLvA-&gt;ShowSubDep();    <span class="hljs-comment">//删除A下属二级部门B</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"========解散子部门========"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    pFstLvA-&gt;DelDepartment(pSndLvB);    <span class="hljs-comment">//析构，资源回收</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=========开始析构========="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">delete</span> pFstLvA;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="c++">=======组建部门结构=======A1部门增加了下属的B2部门A1部门增加了下属的C2部门A1部门增加了下属的D2部门B2部门增加了下属的E3部门B2部门增加了下属的F3部门C2部门增加了下属的G3部门D2部门增加了下属的H3部门========展示子部门========A1部门下属部门： B2 C2 D2========解散子部门========A1部门删除了下属的B2部门B2部门解散E3部门解散F3部门解散=========开始析构=========A1部门解散C2部门解散G3部门解散D2部门解散H3部门解散</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组合模式：一种结构型设计模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;br</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="结构型" scheme="https://jeremyyvv.github.io/tags/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>装饰模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:46:00.000Z</published>
    <updated>2021-03-21T12:47:30.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li><strong>装饰模式：一种结构型设计模式</strong></li><li><strong>应用场景：</strong><br />想要动态的给一个对象添加功能，即希望可以根据需求对现有对象添加不同的功能，以及不同功能的相互组合。<br />如果通过继承实现功能增加，则为了各功能的组合，需要将不同功能排列组合形成数量爆炸的一堆子类。<br />此时可以考虑装饰模式<br /><strong>举例：</strong><br />游戏中的人物和时装。人物可以选择穿上帽子或穿上鞋子，或者都穿上，通过方法展示穿搭结果。<br />比较容易想到的实现方法就是单纯通过继承，一个人物基类，继承出一个穿帽子的人物类，一个穿鞋子的人物类，再一个穿帽子+鞋子的人物类。在只有两种选择时，需要产生3个子类，这种实现方式每增加一种选择就要增加一倍+1数量的子类，非常不可取。</li><li><strong>实现方式：</strong><br />第一步，抽象出一个装饰基类，类中添加一个人物类指针，在构造时传入人物类指针。<br />第二步，增加需要修饰的同名方法，在方法中通过指针调用原方法，再添加新修饰内容。<br />第三步，将装饰基类继承自人物基类，为了使传入装饰类A进行装饰的指针能够传入装饰类B进行其他装饰，并且使传入装饰类A的指针可以指向该装饰类对象。<br />最后一步，实现装饰基类，实现装饰内容。<br />备注：为什么装饰类中增加的方法要与被装饰方法同名呢。因为在第三步中，为了需求，传入装饰类的指针，不一定指向的是人物基类对象，也可能是另一个装饰类对象。所以为了其他装饰类中通过指针调用的原方法存在，对原方法装饰后的方法要与原方法同名。</li><li><strong>优点：</strong><br />可以动态为对象添加功能，相比于继承实现，组合的方式更加灵活而且代码量小很多</li><li><strong>缺点：</strong><br />减少了类的数量，但是在装饰的过程中每一步都会产生一个对象，对于debug来说会困难很多，因为中间每一步产生的对象都很像。</li></ul><hr /><h1 id="装饰模式的简单代码实现"><a class="markdownIt-Anchor" href="#装饰模式的简单代码实现"></a> 装饰模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DECORATOR_HPP</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DECORATOR_HPP</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//人物基类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span>&#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~Man()&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span><span class="hljs-comment">//用于展示</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"A man."</span> &lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-comment">//装饰器抽象类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManWithCloth</span>:</span><span class="hljs-keyword">public</span> Man<span class="hljs-comment">//继承自Man，为了使被装饰的对象可以传入其他装饰器进行组合装饰</span>&#123;<span class="hljs-keyword">public</span>:    ManWithCloth(Man* pMan)        :m_pMan(pMan)&#123;&#125;    <span class="hljs-keyword">virtual</span> ~ManWithCloth()    &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> != m_pMan)        &#123;            <span class="hljs-keyword">delete</span> m_pMan;            m_pMan = <span class="hljs-literal">NULL</span>;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span><span class="hljs-comment">//上述实现方式中的第二步</span>    </span>&#123;        m_pMan-&gt;Show();<span class="hljs-comment">//通过指针调用原指针所指对象的方法，然后添加方法进行修饰</span>        DressUp();<span class="hljs-comment">//对原方法增加修饰</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DressUp</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">//修饰方法在实现类中实现</span><span class="hljs-keyword">private</span>:    Man* m_pMan;&#125;;<span class="hljs-comment">//装饰器实现类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManWearAHat</span>:</span><span class="hljs-keyword">public</span> ManWithCloth&#123;<span class="hljs-keyword">public</span>:    ManWearAHat(Man* pMan)        :ManWithCloth(pMan)&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DressUp</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Wear a Hat."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManWearShoes</span>:</span><span class="hljs-keyword">public</span> ManWithCloth&#123;<span class="hljs-keyword">public</span>:    ManWearShoes(Man* pMan)        :ManWithCloth(pMan)&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DressUp</span><span class="hljs-params">()</span>    </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Wear shoes."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// DECORATOR_HPP</span></span></code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"decorator.hpp"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    Man* pMan = <span class="hljs-keyword">new</span> Man();    pMan-&gt;Show();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"=====Wear Hat====="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    pMan = <span class="hljs-keyword">new</span> ManWearAHat(pMan);    pMan-&gt;Show();    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"====Wear Shoes===="</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    pMan = <span class="hljs-keyword">new</span> ManWearShoes(pMan);    pMan-&gt;Show();    <span class="hljs-keyword">delete</span> pMan;    pMan = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="">A man.=====Wear Hat=====A man.Wear a Hat.====Wear Shoes====A man.Wear a Hat.Wear Shoes.</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;装饰模式：一种结构型设计模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;br</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="结构型" scheme="https://jeremyyvv.github.io/tags/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jeremyyvv.github.io/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-03-21T11:45:00.000Z</published>
    <updated>2021-03-21T12:47:33.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1><ul><li><strong>享元模式：一种结构型设计模式</strong></li><li><strong>应用场景：</strong><br />想象这样一个场景，设计一个两人下棋的小游戏。<br />一方持黑，一方持白，在玩家点击棋盘时，将对应颜色的棋子画在棋盘上。<br />对于白子来说，其属性包括形状、颜色和位置等。其中形状和颜色，对于一方而言，每次摆放时都是相同的属性，不同的只有位置。<br />所以如果每次摆放时都重新对棋子对象设置所有的属性然后描绘在棋盘上，是没有必要的。<br />如果在每局开始第一次设置棋子对象属性后，将其保存起来，之后再取时，只需更改其坐标属性，而不用重新构造对象。省去了每次构造的成本。</li><li><strong>实现方式：</strong><br />创建一个棋子工厂类，在其中使用键值容器map，根据棋子的颜色属性作为键值。<br />每次取属性对象时，在map中进行寻找，如果不存在，则创建新对象并设置颜色等不变属性，如果已经存在，则直接返回已有对象。<br />从工厂获得棋子后只重新设置其坐标属性，然后进行棋盘上的描画。</li></ul><hr /><h1 id="享元模式的简单代码实现"><a class="markdownIt-Anchor" href="#享元模式的简单代码实现"></a> 享元模式的简单代码实现</h1><pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//棋子坐标</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">POINT</span>&#123;</span><span class="hljs-keyword">int</span> m_ix;<span class="hljs-keyword">int</span> m_iy;&#125;;<span class="hljs-comment">//棋子类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CPieces</span>&#123;</span><span class="hljs-keyword">public</span>:CPieces(<span class="hljs-built_in">string</span> strColor):m_strColor(strColor)&#123;&#125;<span class="hljs-comment">//设置棋子坐标的方法</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ix, <span class="hljs-keyword">int</span> iy)</span></span>&#123;m_stPosition.m_ix = ix;m_stPosition.m_iy = iy;&#125;<span class="hljs-comment">//将棋子按照属性描画在棋盘上</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Draw a "</span> &lt;&lt; m_strColor &lt;&lt; <span class="hljs-string">" piece, at position "</span> &lt;&lt; m_stPosition.m_ix &lt;&lt; <span class="hljs-string">"-"</span> &lt;&lt; m_stPosition.m_iy &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">private</span>:<span class="hljs-built_in">string</span> m_strColor;POINT m_stPosition;&#125;;<span class="hljs-comment">//棋子工厂类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CPiecesFactory</span>&#123;</span><span class="hljs-keyword">public</span>:<span class="hljs-function">CPieces* <span class="hljs-title">GetPiece</span><span class="hljs-params">(<span class="hljs-built_in">string</span> strColor)</span></span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == mapPieces[strColor])<span class="hljs-comment">//如果map中原来没有</span>&#123;CPieces* pNewPieces = <span class="hljs-keyword">new</span> CPieces(strColor);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Create a new "</span> &lt;&lt; strColor &lt;&lt; <span class="hljs-string">" Piece "</span> &lt;&lt; <span class="hljs-built_in">endl</span>;mapPieces[strColor] = pNewPieces;&#125;<span class="hljs-keyword">return</span> mapPieces[strColor];&#125;<span class="hljs-keyword">private</span>:<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, CPieces*&gt; mapPieces;<span class="hljs-comment">//按照棋子颜色属性作为键值</span>&#125;;</code></pre><h2 id="主函数中的使用"><a class="markdownIt-Anchor" href="#主函数中的使用"></a> 主函数中的使用</h2><pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;CPiecesFactory* pFactory = <span class="hljs-keyword">new</span> CPiecesFactory();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"-----Round 1-----"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;CPieces* pPieceA = pFactory-&gt;GetPiece(<span class="hljs-string">"White"</span>);pPieceA-&gt;SetPosition(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);pPieceA-&gt;Draw();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"-----Round 2-----"</span> &lt;&lt; <span class="hljs-built_in">endl</span>; CPieces* pPieceB = pFactory-&gt;GetPiece(<span class="hljs-string">"Black"</span>);pPieceB-&gt;SetPosition(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);pPieceB-&gt;Draw();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"-----Round 3-----"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;CPieces* pPieceC = pFactory-&gt;GetPiece(<span class="hljs-string">"White"</span>);pPieceC-&gt;SetPosition(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);pPieceC-&gt;Draw();<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"-----Round 4-----"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;CPieces* pPieceD = pFactory-&gt;GetPiece(<span class="hljs-string">"Black"</span>);pPieceD-&gt;SetPosition(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);pPieceD-&gt;Draw();<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="控制台输出结果"><a class="markdownIt-Anchor" href="#控制台输出结果"></a> 控制台输出结果</h2><pre class="highlight"><code class="">-----Round 1-----Create a new White pieceDraw a White piece, at position 1-2-----Round 2-----Create a new Black pieceDraw a Black piece, at position 3-4-----Round 3-----Draw a White piece, at position 5-6-----Round 4-----Draw a Black piece, at position 7-8</code></pre><hr /><p><em>如有错误，欢迎指正</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简介&quot;&gt;&lt;/a&gt; 简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;享元模式：一种结构型设计模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;br</summary>
      
    
    
    
    <category term="设计模式" scheme="https://jeremyyvv.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="C++" scheme="https://jeremyyvv.github.io/tags/C/"/>
    
    <category term="结构型" scheme="https://jeremyyvv.github.io/tags/%E7%BB%93%E6%9E%84%E5%9E%8B/"/>
    
  </entry>
  
</feed>
