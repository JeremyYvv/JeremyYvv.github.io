<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><title>JeremyYv's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=Edge，chrome=1"><meta name="description" content="个人"><meta name="keywords"><meta name="author" content="JeremyYv"><link rel="short icon" href="/images/favicon.png"><link rel="icon" href="/images/favicon.png"><!--[if lt IE 9]>
<script src="/js/modernizr.js"></script>
<![endif]-->
<link rel="stylesheet" href="/css/iconfont.css">

<link rel="stylesheet" href="/css/index.css?v=202103212320.css">
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="JeremyYv's Blog" type="application/atom+xml">
</head><body><header id="header" class="header-navigation"><nav><div class="logo"><a href="https://JeremyYvv.github.io">JeremyYv's Blog</a></div><h2 id="mnavh"><span class="navicon"></span></h2><ul id="starlist"><li><a href="/">首页</a></li><li><a href="/time.html">时间轴</a></li></ul><div class="searchbox"><div id="search_bar" class="search_bar"><input id="keyboard" placeholder="想搜点什么呢.." type="text" name="keyboard" autocomplete="off" class="input"><p class="search_ico"><span></span></p></div></div></nav></header><article><main><div class="blogtab"><div data-scroll-reveal="enter bottom over 1s" class="blogs"><h3 class="blogtitle"><a href="/2021/03/21/C++/ObjectModel/default-constructor/" target="_blank">默认构造函数</a></h3><span class="blogpic"><a href="/2021/03/21/C++/ObjectModel/default-constructor/" title="默认构造函数"><img src="/" alt=""></a></span><p class="blogtext">C++05标准文档 中 Section 12.1.5 关于默认构造函数的说明

A default constructor for a class X is a constructor of class X that can be c...</p><div class="bloginfo"><ul><li class="author"><a href="/">JeremyYv</a></li><li class="lmname"><a href="/categories/C/">C++</a></li><li class="timer">2021-03-21 20:11:00</li><!--li.view--><!--    span 34567--><!--    | 已阅读--><!--li.like 9999--></ul></div></div><div data-scroll-reveal="enter bottom over 1s" class="blogs"><h3 class="blogtitle"><a href="/2021/03/21/C++/STL/%E7%AE%97%E6%B3%95/" target="_blank">算法</a></h3><span class="blogpic"><a href="/2021/03/21/C++/STL/%E7%AE%97%E6%B3%95/" title="算法"><img src="/" alt=""></a></span><p class="blogtext">条款30：确保目标区间足够大首先了解标准库中的一个算法：
template &lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;
OutputI...</p><div class="bloginfo"><ul><li class="author"><a href="/">JeremyYv</a></li><li class="lmname"><a href="/categories/STL/">STL</a></li><li class="timer">2021-03-21 20:04:00</li><!--li.view--><!--    span 34567--><!--    | 已阅读--><!--li.like 9999--></ul></div></div><div data-scroll-reveal="enter bottom over 1s" class="blogs"><h3 class="blogtitle"><a href="/2021/03/21/C++/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/" target="_blank">迭代器</a></h3><span class="blogpic"><a href="/2021/03/21/C++/STL/%E8%BF%AD%E4%BB%A3%E5%99%A8/" title="迭代器"><img src="/" alt=""></a></span><p class="blogtext">条款26.iterator优先于const_iterator、reverse_iterator及const_reverse_iterator先说这四种迭代器各自的功能对iterator进行递增可以从容器头部遍历到尾部对reverse_...</p><div class="bloginfo"><ul><li class="author"><a href="/">JeremyYv</a></li><li class="lmname"><a href="/categories/STL/">STL</a></li><li class="timer">2021-03-21 20:03:00</li><!--li.view--><!--    span 34567--><!--    | 已阅读--><!--li.like 9999--></ul></div></div><div data-scroll-reveal="enter bottom over 1s" class="blogs"><h3 class="blogtitle"><a href="/2021/03/21/C++/STL/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" target="_blank">关联容器</a></h3><span class="blogpic"><a href="/2021/03/21/C++/STL/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" title="关联容器"><img src="/" alt=""></a></span><p class="blogtext">条款19.理解相等(equality)和等价(equivalence)的区别标准关联容器需要保持有序，所以每个容器必须有一个定义了怎么保持东西有序的比较函数(默认是less)。以set举例，**set&lt;string*&gt; s...</p><div class="bloginfo"><ul><li class="author"><a href="/">JeremyYv</a></li><li class="lmname"><a href="/categories/STL/">STL</a></li><li class="timer">2021-03-21 20:02:00</li><!--li.view--><!--    span 34567--><!--    | 已阅读--><!--li.like 9999--></ul></div></div><div data-scroll-reveal="enter bottom over 1s" class="blogs"><h3 class="blogtitle"><a href="/2021/03/21/C++/STL/vector%E5%92%8Cstring/" target="_blank">vector和string</a></h3><span class="blogpic"><a href="/2021/03/21/C++/STL/vector%E5%92%8Cstring/" title="vector和string"><img src="/" alt=""></a></span><p class="blogtext">条款13.vector和string优先于动态分配的数组使用new来动态分配内存后有三项需要承担的责任，在使用完资源后通过delete释放内存，并与new的形式配对（delete or delete[]），以及确保只delete了一次...</p><div class="bloginfo"><ul><li class="author"><a href="/">JeremyYv</a></li><li class="lmname"><a href="/categories/STL/">STL</a></li><li class="timer">2021-03-21 20:01:00</li><!--li.view--><!--    span 34567--><!--    | 已阅读--><!--li.like 9999--></ul></div></div><div data-scroll-reveal="enter bottom over 1s" class="blogs"><h3 class="blogtitle"><a href="/2021/03/21/C++/STL/%E5%AE%B9%E5%99%A8/" target="_blank">容器</a></h3><span class="blogpic"><a href="/2021/03/21/C++/STL/%E5%AE%B9%E5%99%A8/" title="容器"><img src="/" alt=""></a></span><p class="blogtext">条款1. 慎重选择容器类型标准STL序列容器：vector、string、deque和list标准STL关联容器：set、map、multiset和multimap非标准的关联容器：hash_set、hash_multiset、has...</p><div class="bloginfo"><ul><li class="author"><a href="/">JeremyYv</a></li><li class="lmname"><a href="/categories/STL/">STL</a></li><li class="timer">2021-03-21 20:00:00</li><!--li.view--><!--    span 34567--><!--    | 已阅读--><!--li.like 9999--></ul></div></div><div data-scroll-reveal="enter bottom over 1s" class="blogs"><h3 class="blogtitle"><a href="/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" target="_blank">状态模式</a></h3><span class="blogpic"><a href="/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" title="状态模式"><img src="/" alt=""></a></span><p class="blogtext">状态模式：一种行为型设计模式
应用场景：状态模式主要应用于对象有很多状态，每种状态下有不同的表现，而且在程序运行过程中会频繁变化状态，进而变化变现的情景。(程序运行过程中是否会频繁变化状态，是状态模式与策略模式本质上的区别)
举例：以...</p><div class="bloginfo"><ul><li class="author"><a href="/">JeremyYv</a></li><li class="lmname"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="timer">2021-03-21 19:59:32</li><!--li.view--><!--    span 34567--><!--    | 已阅读--><!--li.like 9999--></ul></div></div><div data-scroll-reveal="enter bottom over 1s" class="blogs"><h3 class="blogtitle"><a href="/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" target="_blank">中介者模式</a></h3><span class="blogpic"><a href="/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" title="中介者模式"><img src="/" alt=""></a></span><p class="blogtext">简介
中介者模式：一种行为型设计模式
应用场景：一般来说，大型的软件在开发的过程中会使用模块化的开发方式。以我现在参与的项目举例，完整的软件包括交互、检索、算路、引导等等多个模块，这样有利于模块之间的独立开发，提高整体开发效率。但是无...</p><div class="bloginfo"><ul><li class="author"><a href="/">JeremyYv</a></li><li class="lmname"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="timer">2021-03-21 19:58:32</li><!--li.view--><!--    span 34567--><!--    | 已阅读--><!--li.like 9999--></ul></div></div><div data-scroll-reveal="enter bottom over 1s" class="blogs"><h3 class="blogtitle"><a href="/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/" target="_blank">职责链模式</a></h3><span class="blogpic"><a href="/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/" title="职责链模式"><img src="/" alt=""></a></span><p class="blogtext">简介
职责链模式：一种行为型设计模式
应用场景：系统中会出现一些请求，而可以处理请求的处理者会有很多，如何将由适当的处理者处理请求，是职责链模式解决的问题。职责链模式将所有处理者连成一条链，请求在链上传播，直至被处理完成。

举例：在...</p><div class="bloginfo"><ul><li class="author"><a href="/">JeremyYv</a></li><li class="lmname"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="timer">2021-03-21 19:57:32</li><!--li.view--><!--    span 34567--><!--    | 已阅读--><!--li.like 9999--></ul></div></div><div data-scroll-reveal="enter bottom over 1s" class="blogs"><h3 class="blogtitle"><a href="/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" target="_blank">模板方法模式</a></h3><span class="blogpic"><a href="/2021/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" title="模板方法模式"><img src="/" alt=""></a></span><p class="blogtext">简介
模板方法模式：一种行为型设计模式
应用场景：模板方法是一种代码复用的基本技术,定义了一个操作中的算法骨架，而将一些步骤延迟到子类中。在使用模板方法时，很重要的一点是模板方法应当指明哪些操作是可以被重写的，以及哪些是必须被重写的。...</p><div class="bloginfo"><ul><li class="author"><a href="/">JeremyYv</a></li><li class="lmname"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="timer">2021-03-21 19:56:32</li><!--li.view--><!--    span 34567--><!--    | 已阅读--><!--li.like 9999--></ul></div></div></div><div class="pagelist"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class='iconfont icon-page-next' ></i></a></div></main><aside class="r_box"><div class="card box"><h2>我的名片</h2><div class="box_con"><h3>JeremyYv</h3>
<p>C++/Python/Web</p>
<p>Email：JeremyYv@foxmal.com</p>
</div></div><div class="category box"><h2>文章分类</h2><div class="box_con"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/STL/">STL</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">24</span></li></ul></div></div><div class="box recommend"><h2>推荐</h2><div class="box_con"><ul></ul></div></div><div class="tags box"><h2>标签</h2><div class="box_con"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/" rel="tag">C++对象模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E5%BA%93/" rel="tag">C++库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E8%AF%AD%E6%B3%95/" rel="tag">C++语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B/" rel="tag">创建型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%93%E6%9E%84%E5%9E%8B/" rel="tag">结构型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B/" rel="tag">行为型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95/" rel="tag">语法</a></li></ul></div></div><div class="wechat box"><h2>我的微信</h2><div class="box_con"><img src="/images/wechat.png"></div></div></aside></article><footer><section class="footer_bottom"><div class="footer_container"><p class="copyright"></p><ul class="social_network"></ul></div></section></footer><div class="cd-top"><i class="iconfont icon-top"></i></div>
<script src="/js/jquery.min.js"></script>
<script src="/js/scrollreveal.js"></script>
<script src="/js/hc-sticky.js"></script>
<script src="/js/canvas-nest.js" type="text/javascript" color="47,135,193" opacity="0.7" zIndex="-2" count="199"></script>
<script src="/js/common.js?v=202103212320.js"></script>
<script src="/js/index.js?v=202103212320.js"></script>
</body></html>